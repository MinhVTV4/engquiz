<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI English Quiz v4 - S·ªï tay & Tra t·ª´</title>
    <!-- T√≠ch h·ª£p Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- T√≠ch h·ª£p Marked.js -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- T√≠ch h·ª£p Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- T√≠ch h·ª£p Tone.js cho hi·ªáu ·ª©ng √¢m thanh -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Be Vietnam Pro', sans-serif; }
        .view { display: none; }
        .view.active { display: block; animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: #0ea5e9; animation: spin 1s ease-in-out infinite; }
        .btn-spinner { width: 20px; height: 20px; border-width: 3px; border-left-color: white; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #passageText, #transcriptContainer, #historyList, #reviewList, #libraryList, #writingFeedbackContainer, #reinforceContent, #learningPathContainer, #reinforcementReviewList, #conversationLog, #deckListContainer, #deckWordList { max-height: 60vh; overflow-y: auto; }
        .topic-container, .vocab-mode-container, #customTopicContainer { transition: all 0.3s ease-in-out; overflow: hidden; }

        /* --- C·∫£i ti·∫øn UI/UX --- */
        @keyframes jiggle { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-6px); } 75% { transform: translateX(6px); } }
        
        .option-btn.correct { animation: jiggle 0.4s ease-in-out; }
        .option-btn.incorrect { animation: shake 0.4s ease-in-out; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex; align-items: center; justify-content: center;
            z-index: 50;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .modal-overlay.active { opacity: 1; visibility: visible; }
        .modal-content {
            background-color: white; padding: 2rem; border-radius: 1.25rem;
            max-width: 90%; width: 600px; box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            position: relative; transform: scale(0.95) translateY(10px); opacity: 0;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
        }
        .modal-overlay.active .modal-content { transform: scale(1) translateY(0); opacity: 1; }

        .translate-icon { cursor: pointer; color: #3b82f6; margin-left: 8px; font-size: 1.25rem; display: inline-block; vertical-align: middle; }
        .highlight-word { background-color: #facc15; color: #1f2937; padding: 2px 0; border-radius: 3px; }
        
        .lookup-word { cursor: pointer; }
        .lookup-word:hover { background-color: #e0f2fe; }
        .saved-word-highlight { border-bottom: 2px dotted #22c55e; cursor: help; }
        .saved-word-highlight:hover { background-color: #dcfce7; }
        .speak-btn { background: none; border: none; cursor: pointer; }

        /* Flashcard Styles */
        .flashcard-container { perspective: 1000px; }
        .flashcard { width: 100%; min-height: 250px; position: relative; transform-style: preserve-3d; transition: transform 0.6s; cursor: pointer; }
        .flashcard.flipped { transform: rotateY(180deg); }
        .flashcard-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; padding: 20px; border-radius: 1rem; border: 2px solid; }
        .flashcard-front { background-color: #e0f2fe; border-color: #7dd3fc; color: #075985; }
        .flashcard-back { background-color: #f0fdf4; border-color: #86efac; color: #15803d; transform: rotateY(180deg); }
        
        /* Writing View Styles */
        #writingFeedbackContainer del { background-color: #fee2e2; text-decoration: line-through; color: #991b1b; padding: 2px; border-radius: 3px; }
        #writingFeedbackContainer ins { background-color: #dcfce7; text-decoration: none; color: #166534; padding: 2px; border-radius: 3px; }
        
        /* Styles for Marked.js output */
        .prose p { margin-bottom: 0.75rem; }
        .prose ul { list-style-type: disc; padding-left: 1.5rem; margin-bottom: 0.75rem; }
        .prose li { margin-bottom: 0.25rem; }
        .prose strong { font-weight: 600; }

        /* Diagnostic Conversation Styles */
        @keyframes mic-pulse {
            0% { box-shadow: 0 0 0 0 rgba(199, 210, 254, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(199, 210, 254, 0); }
            100% { box-shadow: 0 0 0 0 rgba(199, 210, 254, 0); }
        }
        .mic-recording { animation: mic-pulse 1.5s infinite; }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 flex items-center justify-center min-h-screen p-4">

    <div id="appContainer" class="w-full max-w-2xl mx-auto bg-white rounded-2xl shadow-xl p-6 md:p-8 transition-all duration-500">

        <!-- M√†n h√¨nh 0: ƒêƒÉng nh·∫≠p / ƒêƒÉng k√Ω -->
        <div id="auth-view" class="view active">
            <h1 class="text-3xl font-bold text-center text-sky-600 mb-2">Ch√†o m·ª´ng b·∫°n!</h1>
            <p class="text-center text-slate-500 mb-8">ƒêƒÉng nh·∫≠p ho·∫∑c ƒêƒÉng k√Ω ƒë·ªÉ l∆∞u ti·∫øn tr√¨nh h·ªçc</p>
            <div class="space-y-4">
                <div><label for="emailInput" class="block text-sm font-medium mb-1 text-slate-700">Email</label><input type="email" id="emailInput" placeholder="ten@email.com" class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition"></div>
                <div><label for="passwordInput" class="block text-sm font-medium mb-1 text-slate-700">M·∫≠t kh·∫©u</label><input type="password" id="passwordInput" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition"></div>
            </div>
            <p id="authError" class="text-red-500 text-sm text-center mt-4 h-5"></p>
            <div class="mt-6 space-y-3">
                 <button id="loginButton" class="w-full bg-sky-500 hover:bg-sky-600 text-white font-bold py-3 px-4 rounded-lg text-lg transition-transform transform hover:scale-105 flex items-center justify-center gap-3 disabled:bg-sky-300"><span class="btn-text">ƒêƒÉng nh·∫≠p</span><div class="spinner btn-spinner hidden"></div></button>
                 <button id="registerButton" class="w-full bg-slate-600 hover:bg-slate-700 text-white font-bold py-3 px-4 rounded-lg text-lg transition-transform transform hover:scale-105 flex items-center justify-center gap-3 disabled:bg-slate-400"><span class="btn-text">ƒêƒÉng k√Ω</span><div class="spinner btn-spinner hidden"></div></button>
            </div>
        </div>

        <!-- M√†n h√¨nh 1: Thi·∫øt l·∫≠p b√†i ki·ªÉm tra -->
        <div id="setup-view" class="view">
            <div class="flex justify-between items-start mb-6">
                 <div><h1 class="text-3xl font-bold text-sky-600">AI English Quiz</h1><p id="welcomeMessage" class="text-slate-500">Ch√†o m·ª´ng tr·ªü l·∫°i!</p></div>
                 <div class="flex flex-col items-end space-y-2">
                    <div id="streakDisplay" class="flex items-center justify-center bg-orange-100 text-orange-600 font-bold text-sm px-3 py-1 rounded-full">
                        <span class="mr-1">üî•</span>
                        <span id="streakCount">0</span>
                    </div>
                    <div class="flex space-x-2">
                        <button id="showNotebookButton" class="bg-teal-500 hover:bg-teal-600 text-white font-semibold py-2 px-4 rounded-lg text-sm">S·ªï tay</button>
                        <button id="showHistoryButton" class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg text-sm">L·ªãch s·ª≠</button>
                        <button id="logoutButton" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg text-sm">ƒêƒÉng xu·∫•t</button>
                    </div>
                 </div>
            </div>
            
            <div id="learningPathCTA" class="hidden mb-6 p-5 bg-gradient-to-r from-teal-500 to-cyan-500 rounded-xl text-white shadow-lg">
                <h2 class="text-2xl font-bold mb-2">L·ªô tr√¨nh c·ªßa b·∫°n ƒë√£ s·∫µn s√†ng!</h2>
                <p class="mb-4 opacity-90">Ti·∫øp t·ª•c h√†nh tr√¨nh chinh ph·ª•c ti·∫øng Anh c·ªßa b·∫°n ngay th√¥i.</p>
                <button id="continuePathButton" class="w-full bg-white hover:bg-slate-100 text-teal-600 font-bold py-3 px-4 rounded-lg text-lg transition-transform transform hover:scale-105">Ti·∫øp t·ª•c L·ªô tr√¨nh</button>
            </div>
            
            <div id="placementTestContainer" class="mb-6 p-5 bg-gradient-to-r from-sky-500 to-indigo-500 rounded-xl text-white shadow-lg">
                <h2 class="text-2xl font-bold mb-2">B·∫Øt ƒë·∫ßu L·ªô tr√¨nh h·ªçc c·ªßa b·∫°n!</h2>
                <p class="mb-4 opacity-90">L√†m m·ªôt b√†i ki·ªÉm tra ng·∫Øn ƒë·ªÉ AI x√°c ƒë·ªãnh tr√¨nh ƒë·ªô v√† t·∫°o l·ªô tr√¨nh h·ªçc t·∫≠p c√° nh√¢n h√≥a cho ri√™ng b·∫°n.</p>
                <button id="startPlacementTestButton" class="w-full bg-white hover:bg-slate-100 text-indigo-600 font-bold py-3 px-4 rounded-lg text-lg transition-transform transform hover:scale-105">L√†m b√†i ki·ªÉm tra tr√¨nh ƒë·ªô</button>
            </div>

            <button id="quickStartButton" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-4 rounded-lg text-xl transition-transform transform hover:scale-105 flex items-center justify-center gap-3 mb-4">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2z"></polygon></svg>
                Luy·ªán t·∫≠p nhanh
            </button>
            <button id="showLibraryButton" class="w-full bg-amber-500 hover:bg-amber-600 text-white font-bold py-4 px-4 rounded-lg text-xl transition-transform transform hover:scale-105 flex items-center justify-center gap-3 mb-6">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>
                Th∆∞ vi·ªán b√†i t·∫≠p
            </button>
            
            <div class="space-y-6">
                <div class="p-4 bg-slate-50 rounded-lg border">
                    <h3 class="font-bold text-slate-700 mb-3 text-lg">T√πy ch·ªânh b√†i luy·ªán t·∫≠p</h3>
                    <div>
                        <label for="quizTypeSelect" class="block text-md font-semibold mb-2 text-slate-700">Ch·ªçn k·ªπ nƒÉng:</label>
                        <select id="quizTypeSelect" class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition bg-white">
                            <option value="vocabulary" selected>T·ª´ v·ª±ng (Vocabulary)</option>
                            <option value="reading">ƒê·ªçc hi·ªÉu (Reading)</option>
                            <option value="grammar">Ng·ªØ ph√°p (Grammar)</option>
                            <option value="listening">Nghe hi·ªÉu (Listening)</option>
                            <option value="writing">Luy·ªán Vi·∫øt (Writing)</option>
                        </select>
                    </div>
                    <div id="vocabModeContainer" class="vocab-mode-container mt-4">
                        <label for="vocabModeSelect" class="block text-md font-semibold mb-2 text-slate-700">Ch·ªçn ch·∫ø ƒë·ªô:</label>
                        <select id="vocabModeSelect" class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition bg-white">
                            <option value="multiple_choice" selected>Tr·∫Øc nghi·ªám</option>
                            <option value="fill_in_the_blank">ƒêi·ªÅn v√†o ch·ªó tr·ªëng</option>
                            <option value="word_formation">D·∫°ng c·ªßa t·ª´</option>
                            <option value="word_scramble">S·∫Øp x·∫øp ch·ªØ c√°i</option>
                            <option value="matching">N·ªëi t·ª´</option>
                            <option value="flashcard">Flashcards</option>
                        </select>
                    </div>
                    <div id="topicContainer" class="topic-container mt-4">
                        <label for="topicSelect" class="block text-md font-semibold mb-2 text-slate-700">Ch·ªçn ch·ªß ƒë·ªÅ:</label>
                        <select id="topicSelect" class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition bg-white">
                            <option value="Travel">Du l·ªãch</option>
                            <option value="Technology" selected>C√¥ng ngh·ªá</option>
                            <option value="Food & Cooking">·∫®m th·ª±c</option>
                            <option value="Health & Fitness">S·ª©c kh·ªèe</option>
                            <option value="Work & Business">C√¥ng vi·ªác</option>
                            <option value="Movies & Entertainment">Gi·∫£i tr√≠</option>
                            <option value="Sports">Th·ªÉ thao</option>
                            <option value="custom">Kh√°c (T·ª± nh·∫≠p)...</option>
                        </select>
                    </div>
                    <div id="customTopicContainer" class="hidden mt-4">
                        <label for="customTopicInput" class="block text-md font-semibold mb-2 text-slate-700">Nh·∫≠p ch·ªß ƒë·ªÅ c·ªßa b·∫°n:</label>
                        <input type="text" id="customTopicInput" placeholder="VD: V≈© tr·ª•, L·ªãch s·ª≠, √Çm nh·∫°c..." class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition">
                    </div>
                    <div class="mt-4"><label for="levelSelect" class="block text-md font-semibold mb-2 text-slate-700">Ch·ªçn tr√¨nh ƒë·ªô:</label><select id="levelSelect" class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition bg-white"><option value="A2">A2</option><option value="B1" selected>B1</option><option value="B2">B2</option><option value="C1">C1</option></select></div>
                    <div id="questionCountContainer" class="mt-4">
                        <label for="questionCountSelect" class="block text-md font-semibold mb-2 text-slate-700">S·ªë l∆∞·ª£ng c√¢u h·ªèi:</label>
                        <select id="questionCountSelect" class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition bg-white">
                            <option value="5" selected>5 c√¢u</option>
                            <option value="10">10 c√¢u</option>
                            <option value="15">15 c√¢u</option>
                        </select>
                    </div>
                    <button id="startQuizButton" class="mt-6 w-full bg-sky-500 hover:bg-sky-600 text-white font-bold py-3 px-4 rounded-lg text-lg transition-transform transform hover:scale-105 flex items-center justify-center gap-3">B·∫Øt ƒë·∫ßu</button>
                </div>
                <div class="mt-6 flex items-center justify-center">
                    <input type="checkbox" id="autoAdvanceCheckbox" class="h-4 w-4 rounded border-gray-300 text-sky-600 focus:ring-sky-500">
                    <label for="autoAdvanceCheckbox" class="ml-2 block text-sm text-gray-900">T·ª± ƒë·ªông chuy·ªÉn c√¢u sau khi tr·∫£ l·ªùi</label>
                </div>
            </div>
        </div>

        <!-- M√†n h√¨nh Ch·ªçn lo·∫°i ki·ªÉm tra -->
        <div id="assessment-choice-view" class="view">
            <h2 class="text-3xl font-bold text-slate-800 mb-2 text-center">Ch·ªçn ph∆∞∆°ng ph√°p ki·ªÉm tra</h2>
            <p class="text-slate-500 text-lg mb-8 text-center">H√£y ch·ªçn c√°ch b·∫°n mu·ªën AI ƒë√°nh gi√° tr√¨nh ƒë·ªô c·ªßa m√¨nh.</p>
            <div class="space-y-4">
                <button id="startTraditionalTestButton" class="w-full p-6 border-2 border-slate-300 rounded-lg hover:bg-slate-100 hover:border-sky-400 transition text-left">
                    <div class="flex items-center gap-4">
                        <div class="text-4xl">üìù</div>
                        <div>
                            <h3 class="text-xl font-bold text-sky-700">B√†i tr·∫Øc nghi·ªám</h3>
                            <p class="text-slate-600">L√†m m·ªôt b√†i ki·ªÉm tra 12 c√¢u h·ªèi ƒë·ªÉ ƒë√°nh gi√° nhanh c√°c k·ªπ nƒÉng.</p>
                        </div>
                    </div>
                </button>
                <button id="startDiagnosticConversationButton" class="w-full p-6 border-2 border-slate-300 rounded-lg hover:bg-slate-100 hover:border-purple-400 transition text-left">
                    <div class="flex items-center gap-4">
                        <div class="text-4xl">üí¨</div>
                        <div>
                            <h3 class="text-xl font-bold text-purple-700">Tr√≤ chuy·ªán v·ªõi AI</h3>
                            <p class="text-slate-600">Tham gia m·ªôt cu·ªôc h·ªôi tho·∫°i ng·∫Øn ƒë·ªÉ AI ƒë√°nh gi√° to√†n di·ªán h∆°n. <span class="text-xs font-bold text-white bg-purple-500 px-2 py-1 rounded-full ml-2">N√ÇNG CAO</span></p>
                        </div>
                    </div>
                </button>
            </div>
            <button id="backToSetupFromChoice" class="mt-8 w-full text-slate-600 hover:text-slate-800 font-semibold py-2 px-4 rounded-lg text-md transition">Quay l·∫°i</button>
        </div>
        
        <!-- M√†n h√¨nh H·ªôi tho·∫°i Ch·∫©n ƒëo√°n -->
        <div id="diagnostic-conversation-view" class="view">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-3xl font-bold text-purple-600">Tr√≤ chuy·ªán Ch·∫©n ƒëo√°n</h2>
                <button id="endDiagnosticConversationButton" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg text-sm">K·∫øt th√∫c</button>
            </div>
            <div class="min-h-[400px] flex flex-col">
                <div id="conversationLog" class="flex-grow space-y-4 p-4 bg-slate-50 rounded-lg border mb-4 overflow-y-auto">
                    <!-- AI and user messages will appear here -->
                </div>
                <div id="conversationInputArea" class="mt-auto flex items-center gap-3">
                    <button id="micButton" class="p-4 rounded-full bg-indigo-200 hover:bg-indigo-300 text-indigo-700 transition">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line></svg>
                    </button>
                    <input type="text" id="conversationTextInput" class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-purple-500" placeholder="Ho·∫∑c g√µ c√¢u tr·∫£ l·ªùi c·ªßa b·∫°n ·ªü ƒë√¢y...">
                    <button id="sendTextButton" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-4 rounded-lg">G·ª≠i</button>
                </div>
            </div>
        </div>

        <!-- M√†n h√¨nh L·ªô tr√¨nh h·ªçc t·∫≠p -->
        <div id="learning-path-view" class="view">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-3xl font-bold text-teal-600">L·ªô tr√¨nh c·ªßa b·∫°n</h2>
                <button id="backToSetupFromPath" class="bg-slate-500 hover:bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg text-sm">Quay l·∫°i</button>
            </div>
            <div id="learningPathContainer" class="space-y-3 pr-2">
                <!-- L·ªô tr√¨nh s·∫Ω ƒë∆∞·ª£c render ·ªü ƒë√¢y -->
            </div>
        </div>
        
        <!-- M√†n h√¨nh Ch·ªçn m·ª•c ti√™u -->
        <div id="goal-setting-view" class="view">
            <h2 class="text-3xl font-bold text-slate-800 mb-2 text-center">M·ª•c ti√™u c·ªßa b·∫°n l√† g√¨?</h2>
            <p class="text-slate-500 text-lg mb-8 text-center">Ch·ªçn m·ªôt m·ª•c ti√™u ƒë·ªÉ AI c√° nh√¢n h√≥a l·ªô tr√¨nh t·ªët h∆°n.</p>
            <div id="goalOptionsContainer" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <!-- C√°c m·ª•c ti√™u s·∫Ω ƒë∆∞·ª£c render ·ªü ƒë√¢y -->
            </div>
        </div>

        <!-- M√†n h√¨nh Th∆∞ vi·ªán b√†i t·∫≠p -->
        <div id="library-view" class="view">
            <div class="flex justify-between items-center mb-4"><h2 class="text-3xl font-bold text-amber-600">Th∆∞ vi·ªán b√†i t·∫≠p</h2><button id="backToSetupFromLibrary" class="bg-slate-500 hover:bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg text-sm">Quay l·∫°i</button></div>
            <div id="libraryFilters" class="mb-4 flex flex-col md:flex-row gap-4"></div>
            <div id="libraryList" class="space-y-3"></div>
        </div>

        <!-- M√†n h√¨nh L·ªãch s·ª≠ l√†m b√†i -->
        <div id="history-view" class="view">
            <div class="flex justify-between items-center mb-4"><h2 class="text-3xl font-bold text-indigo-600">L·ªãch s·ª≠ & Ph√¢n t√≠ch</h2><button id="backToSetupFromHistory" class="bg-slate-500 hover:bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg text-sm">Quay l·∫°i</button></div>
            <div id="historyDashboard" class="mb-4 grid grid-cols-1 md:grid-cols-3 gap-4 text-center"></div>
            <div id="recommendationsContainer" class="mb-4"></div>
            <div id="historyFilters" class="mb-4 flex flex-col md:flex-row gap-4">
                <select id="filterSkill" class="w-full md:w-1/2 p-2 border border-slate-300 rounded-lg bg-white"><option value="all">T·∫•t c·∫£ K·ªπ nƒÉng</option><option value="vocabulary">T·ª´ v·ª±ng</option><option value="reading">ƒê·ªçc hi·ªÉu</option><option value="grammar">Ng·ªØ ph√°p</option><option value="listening">Nghe hi·ªÉu</option><option value="writing">Luy·ªán vi·∫øt</option></select>
                <select id="filterLevel" class="w-full md:w-1/2 p-2 border border-slate-300 rounded-lg bg-white"><option value="all">T·∫•t c·∫£ Tr√¨nh ƒë·ªô</option><option value="A2">A2</option><option value="B1">B1</option><option value="B2">B2</option><option value="C1">C1</option></select>
            </div>
            <div id="historyList" class="space-y-3 max-h-64 overflow-y-auto pr-2"></div>
        </div>

        <!-- NEW: M√†n h√¨nh S·ªï tay - Danh s√°ch B·ªô th·∫ª -->
        <div id="notebook-decks-view" class="view">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-3xl font-bold text-teal-600">S·ªï tay T·ª´ v·ª±ng</h2>
                <button id="backToSetupFromDecks" class="bg-slate-500 hover:bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg text-sm">Quay l·∫°i</button>
            </div>
            <button id="showCreateDeckModalButton" class="w-full mb-6 bg-teal-500 hover:bg-teal-600 text-white font-bold py-3 px-4 rounded-lg text-lg transition-transform transform hover:scale-105 flex items-center justify-center gap-3">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                T·∫°o b·ªô th·∫ª m·ªõi
            </button>
            <div id="deckListContainer" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <!-- Danh s√°ch c√°c b·ªô th·∫ª s·∫Ω ƒë∆∞·ª£c render ·ªü ƒë√¢y -->
            </div>
        </div>

        <!-- NEW: M√†n h√¨nh Chi ti·∫øt B·ªô th·∫ª & Tra t·ª´ -->
        <div id="deck-details-view" class="view">
            <div class="flex justify-between items-center mb-4">
                <h2 id="deckDetailTitle" class="text-2xl md:text-3xl font-bold text-teal-700 truncate"></h2>
                <button id="backToDecksListButton" class="bg-slate-500 hover:bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg text-sm flex-shrink-0">Quay l·∫°i</button>
            </div>

            <!-- Box Tra t·ª´ nhanh -->
            <div class="p-4 bg-sky-50 border border-sky-200 rounded-xl mb-6">
                <h3 class="text-lg font-bold text-sky-800 mb-3">Th√™m t·ª´ v√†o b·ªô th·∫ª n√†y</h3>
                <div class="flex flex-col sm:flex-row gap-3">
                    <input type="text" id="quickLookupInput" placeholder="Nh·∫≠p t·ª´ ti·∫øng Anh c·∫ßn tra..." class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition">
                    <button id="quickLookupButton" class="bg-sky-500 hover:bg-sky-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center gap-2 disabled:bg-sky-300 flex-shrink-0">
                        <span class="btn-text">Tra c·ª©u & Th√™m</span>
                        <div class="spinner btn-spinner hidden"></div>
                    </button>
                </div>
                <div id="quickLookupResult" class="mt-4"></div>
            </div>

            <!-- Khu v·ª±c Qu·∫£n l√Ω -->
            <div class="mb-4">
                <input type="text" id="deckSearchInput" placeholder="T√¨m ki·∫øm t·ª´ trong b·ªô th·∫ª..." class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-teal-500">
            </div>
            <div class="flex items-center justify-between mb-3 p-2 bg-slate-100 rounded-md">
                <div class="flex items-center">
                    <input type="checkbox" id="selectAllWordsCheckbox" class="h-5 w-5 rounded border-gray-300 text-teal-600 focus:ring-teal-500">
                    <label for="selectAllWordsCheckbox" class="ml-2 text-sm font-medium text-slate-700">Ch·ªçn t·∫•t c·∫£</label>
                </div>
                 <button id="deleteSelectedWordsButton" class="text-red-500 hover:text-red-700 font-semibold text-sm disabled:opacity-50" disabled>X√≥a m·ª•c ƒë√£ ch·ªçn</button>
            </div>
            <div id="deckWordList" class="space-y-2">
                <!-- Danh s√°ch t·ª´ trong b·ªô th·∫ª s·∫Ω ƒë∆∞·ª£c render ·ªü ƒë√¢y -->
            </div>
            
            <div class="mt-6 sticky bottom-0 bg-white py-4 border-t">
                 <button id="reviewSelectedWordsButton" class="w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-4 rounded-lg text-lg disabled:bg-orange-300 disabled:cursor-not-allowed" disabled>√în t·∫≠p (0 t·ª´)</button>
            </div>
        </div>


        <!-- M√†n h√¨nh ƒêang t·∫£i c√¢u h·ªèi -->
        <div id="loading-view" class="view text-center py-16">
            <div class="spinner mx-auto mb-6"></div><h2 id="loadingTitle" class="text-2xl font-semibold text-slate-700">ƒêang t·∫°o b√†i ki·ªÉm tra...</h2><p id="loadingMessage" class="text-slate-500">AI ƒëang chu·∫©n b·ªã c√°c c√¢u h·ªèi v·ªÅ ch·ªß ƒë·ªÅ <b id="loadingTopic"></b> cho b·∫°n. Vui l√≤ng ch·ªù!</p>
        </div>

        <!-- M√†n h√¨nh L√†m b√†i ki·ªÉm tra -->
        <div id="quiz-view" class="view">
            <div id="quizHeader" class="text-center mb-6 border-b pb-4">
                <h2 id="quizTitle" class="text-2xl font-bold text-sky-700"></h2>
                <p id="quizSubtitle" class="text-slate-500 mt-1"></p>
            </div>
            <div class="flex justify-between items-center mb-4"><div id="progress" class="text-lg font-semibold text-slate-600">C√¢u 1 / 5</div><div id="score" class="text-lg font-bold text-sky-600">ƒêi·ªÉm: 0</div></div>
            <div class="w-full bg-slate-200 rounded-full h-2.5 mb-8"><div id="progressBar" class="bg-sky-500 h-2.5 rounded-full" style="width: 20%"></div></div>
            <div id="audioPlayerContainer" class="hidden mb-2 p-4 bg-slate-800 text-white rounded-lg flex items-center justify-center space-x-4">
                <button id="playAudioBtn" class="p-3 bg-sky-500 rounded-full hover:bg-sky-600 disabled:bg-slate-500 disabled:cursor-not-allowed">
                    <svg id="playIcon" class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"></path></svg>
                    <svg id="pauseIcon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                </button>
                <div id="audioStatus" class="text-sm">Nh·∫•n ƒë·ªÉ nghe</div>
            </div>
            <div id="transcriptControls" class="hidden mb-4 text-center">
                <button id="showTranscriptBtn" class="text-sm text-sky-600 hover:underline">Hi·ªán l·ªùi tho·∫°i</button>
            </div>
            <div id="transcriptContainer" class="hidden mb-6 p-3 bg-slate-100 rounded-lg text-slate-700 text-lg leading-relaxed"></div>
            <div id="passageContainer" class="mb-6 bg-slate-50 p-4 rounded-lg border border-slate-200 hidden"><p id="passageText"></p></div>
            <div id="questionContainer" class="mb-6"><p class="text-xl md:text-2xl font-semibold leading-relaxed mb-6"><span id="questionText"></span><span id="translateQuestionBtn" class="translate-icon" title="D·ªãch c√¢u h·ªèi n√†y">üåê</span></p><div id="optionsContainer" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div></div>
            <div id="feedbackContainer" class="mt-6 p-4 rounded-lg min-h-[100px]"></div>
            <button id="nextQuestionButton" class="hidden mt-6 w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg text-lg transition">Ti·∫øp t·ª•c</button>
        </div>

        <!-- M√†n h√¨nh Luy·ªán Vi·∫øt -->
        <div id="writing-view" class="view">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-3xl font-bold text-cyan-600">Luy·ªán Vi·∫øt</h2>
                <button id="backToSetupFromWriting" class="bg-slate-500 hover:bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg text-sm">Quay l·∫°i</button>
            </div>
            <div class="space-y-6">
                <div>
                    <h3 class="text-lg font-semibold text-slate-700 mb-2">Ch·ªß ƒë·ªÅ:</h3>
                    <p id="writingTopic" class="text-xl p-4 bg-slate-100 rounded-lg border border-slate-200"></p>
                </div>
                <div>
                    <label for="writingInput" class="block text-lg font-semibold mb-2 text-slate-700">B√†i vi·∫øt c·ªßa b·∫°n (√≠t nh·∫•t 30 t·ª´):</label>
                    <textarea id="writingInput" rows="8" class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 transition" placeholder="Vi·∫øt b√†i c·ªßa b·∫°n ·ªü ƒë√¢y..."></textarea>
                    <p id="wordCount" class="text-sm text-right text-slate-500 mt-1">0 t·ª´</p>
                </div>
                <button id="getFeedbackButton" class="w-full bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-4 rounded-lg text-lg flex items-center justify-center gap-3 disabled:bg-cyan-300">
                    <span class="btn-text">Nh·∫≠n ph·∫£n h·ªìi t·ª´ AI</span>
                    <div class="spinner btn-spinner hidden"></div>
                </button>
            </div>
            <div id="writingFeedbackContainer" class="mt-8 space-y-6 hidden"></div>
        </div>


        <!-- M√†n h√¨nh K·∫øt qu·∫£ -->
        <div id="result-view" class="view text-center">
            <h2 class="text-3xl font-bold text-slate-800 mb-2">Ho√†n th√†nh!</h2><p class="text-slate-500 text-lg mb-6">ƒê√¢y l√† k·∫øt qu·∫£ c·ªßa b·∫°n:</p>
            <div id="resultScoreContainer" class="bg-sky-100 border-2 border-sky-300 rounded-xl p-8 mb-8"><p class="text-2xl font-semibold mb-2">T·ªïng ƒëi·ªÉm</p><p id="finalScore" class="text-6xl font-bold text-sky-600">4 / 5</p></div>
            <p id="resultMessage" class="text-lg mb-8"></p>
            <div class="flex space-x-4">
                <button id="playAgainButton" class="w-full bg-sky-500 hover:bg-sky-600 text-white font-bold py-4 px-4 rounded-lg text-xl transition">L√†m l·∫°i</button>
                <button id="reviewAnswersButton" class="w-full bg-purple-500 hover:bg-purple-600 text-white font-bold py-4 px-4 rounded-lg text-xl transition">Xem l·∫°i b√†i l√†m</button>
            </div>
            <button id="viewHistoryFromResultButton" class="mt-4 w-full text-indigo-600 hover:text-indigo-800 font-semibold py-2 px-4 rounded-lg text-md transition">Xem l·ªãch s·ª≠ & ph√¢n t√≠ch</button>
        </div>
        
        <!-- M√†n h√¨nh Xem l·∫°i b√†i l√†m -->
        <div id="review-view" class="view">
             <div class="flex justify-between items-center mb-6">
                <h2 class="text-3xl font-bold text-purple-600">Xem l·∫°i b√†i l√†m</h2>
                <button id="backToPreviousViewButton" class="bg-slate-500 hover:bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg text-sm">Quay l·∫°i</button>
            </div>
            <div id="reviewList" class="space-y-4"></div>
        </div>
        
        <!-- M√†n h√¨nh √în t·∫≠p & C·ªßng c·ªë -->
        <div id="reinforcement-view" class="view">
             <div class="flex justify-between items-center mb-6">
                <h2 class="text-3xl font-bold text-orange-600">√în t·∫≠p & C·ªßng c·ªë</h2>
                <button id="backToPathFromReinforcement" class="bg-slate-500 hover:bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg text-sm">V·ªÅ L·ªô tr√¨nh</button>
            </div>
            <p class="text-slate-600 mb-4">ƒê√¢y l√† nh·ªØng c√¢u b·∫°n ƒë√£ l√†m sai. H√£y xem l·∫°i v√† nh·∫•n v√†o n√∫t "B√†i h·ªçc t·ª´ AI" ƒë·ªÉ hi·ªÉu r√µ h∆°n tr∆∞·ªõc khi th·ª≠ l·∫°i nh√©.</p>
            <div id="reinforcementReviewList" class="space-y-4"></div>
             <button id="retryPathStepFromReinforcement" class="mt-6 w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-4 rounded-lg text-lg transition">Th·ª≠ l·∫°i b∆∞·ªõc n√†y</button>
        </div>
        
        <!-- M√†n h√¨nh K·∫øt qu·∫£ Ki·ªÉm tra Tr√¨nh ƒë·ªô -->
        <div id="placement-result-view" class="view text-center">
            <h2 class="text-3xl font-bold text-slate-800 mb-2">K·∫øt qu·∫£ Ki·ªÉm tra Tr√¨nh ƒë·ªô</h2>
            <p class="text-slate-500 text-lg mb-6">ƒê√¢y l√† ph√¢n t√≠ch c·ªßa AI v·ªÅ nƒÉng l·ª±c c·ªßa b·∫°n:</p>
            <div id="placementResultContainer" class="bg-indigo-100 border-2 border-indigo-300 rounded-xl p-8 mb-8 text-left">
                <div class="spinner mx-auto"></div>
            </div>
            <div id="diagnosticChartContainer" class="hidden my-6"><canvas id="diagnosticChart"></canvas></div>
            <button id="createPathButton" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-4 px-4 rounded-lg text-xl transition hidden">T·∫°o L·ªô tr√¨nh H·ªçc t·∫≠p cho t√¥i</button>
            <button id="backToSetupFromPlacement" class="mt-4 w-full text-slate-600 hover:text-slate-800 font-semibold py-2 px-4 rounded-lg text-md transition">Quay l·∫°i sau</button>
        </div>

        <!-- Th√¥ng b√°o l·ªói chung -->
        <div id="error-view" class="view text-center text-red-600 bg-red-100 p-6 rounded-lg">
             <h2 class="text-2xl font-bold mb-4">ƒê√£ x·∫£y ra l·ªói</h2><p id="errorMessage" class="mb-6"></p><button id="backToSetupButton" class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-lg">Quay l·∫°i</button>
        </div>
    </div>
    
    <!-- Modals -->
    <div id="translationModal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="text-xl font-bold text-slate-800 mb-4">B·∫£n d·ªãch</h3>
            <div id="translationResult" class="bg-slate-100 p-4 rounded-lg min-h-[80px]">
                <div class="spinner mx-auto"></div>
            </div>
            <button id="closeTranslationModal" class="mt-6 w-full bg-slate-500 hover:bg-slate-600 text-white font-bold py-2 px-4 rounded-lg">ƒê√≥ng</button>
        </div>
    </div>

    <div id="confirmModal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="confirmTitle" class="text-xl font-bold text-slate-800 mb-2">X√°c nh·∫≠n</h3>
            <p id="confirmMessage" class="text-slate-600 mb-6">B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën th·ª±c hi·ªán h√†nh ƒë·ªông n√†y?</p>
            <div class="flex justify-end space-x-3">
                <button id="confirmCancelBtn" class="bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-2 px-5 rounded-lg">H·ªßy</button>
                <button id="confirmOkBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-5 rounded-lg">X√≥a</button>
            </div>
        </div>
    </div>

    <!-- NEW: Create Deck Modal -->
    <div id="createDeckModal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="text-xl font-bold text-slate-800 mb-4">T·∫°o b·ªô th·∫ª m·ªõi</h3>
            <div>
                <label for="newDeckNameInput" class="block text-sm font-medium mb-1 text-slate-700">T√™n b·ªô th·∫ª</label>
                <input type="text" id="newDeckNameInput" placeholder="VD: IELTS Writing Task 2" class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-teal-500">
            </div>
            <div class="flex justify-end space-x-3 mt-6">
                <button id="cancelCreateDeckBtn" class="bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-2 px-5 rounded-lg">H·ªßy</button>
                <button id="confirmCreateDeckBtn" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-5 rounded-lg">T·∫°o</button>
            </div>
        </div>
    </div>

    <div id="reinforceModal" class="modal-overlay">
        <div class="modal-content">
            <div class="flex justify-between items-center pb-4 border-b mb-4">
                <h3 id="reinforceTitle" class="text-2xl font-bold text-fuchsia-600">B√†i h·ªçc t·ª´ AI</h3>
                <button id="closeReinforceModal" class="text-2xl font-bold text-slate-400 hover:text-red-500">&times;</button>
            </div>
            <div id="reinforceContent" class="space-y-4">
                <div class="spinner mx-auto"></div>
            </div>
        </div>
    </div>

    <!-- UPDATED: Word Info Modal -->
    <div id="wordInfoModal" class="modal-overlay">
        <div class="modal-content">
            <div class="flex justify-between items-center pb-4 border-b mb-4">
                <div id="wordInfoTitleContainer" class="flex items-center gap-3">
                    <h3 id="wordInfoTitle" class="text-2xl font-bold text-sky-600 capitalize"></h3>
                    <button id="wordInfoSpeakBtn" class="speak-btn">
                         <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-sky-500 hover:text-sky-700"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
                    </button>
                </div>
                <button id="closeWordInfoModal" class="text-2xl font-bold text-slate-400 hover:text-red-500">&times;</button>
            </div>
            <div id="wordInfoContent" class="space-y-4 min-h-[100px]">
                <div class="spinner mx-auto"></div>
            </div>
            <div class="mt-6 space-y-3">
                <div>
                    <label for="deckSelectDropdown" class="block text-sm font-medium mb-1 text-slate-700">Ch·ªçn b·ªô th·∫ª ƒë·ªÉ l∆∞u:</label>
                    <select id="deckSelectDropdown" class="w-full p-3 border border-slate-300 rounded-lg bg-white focus:ring-2 focus:ring-teal-500"></select>
                </div>
                <button id="saveWordToDeckBtn" class="w-full bg-teal-500 hover:bg-teal-600 text-white font-bold py-3 px-4 rounded-lg text-lg transition disabled:bg-teal-300 disabled:cursor-not-allowed">L∆∞u v√†o b·ªô th·∫ª</button>
            </div>
        </div>
    </div>


    <script type="module">
        // --- IMPORTS ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-analytics.js";
        import { getAI, getGenerativeModel, GoogleAIBackend } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-ai.js";
        import { getAuth, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, getDocs, serverTimestamp, doc, getDoc, setDoc, deleteDoc, updateDoc, where, writeBatch } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-firestore.js";

        // --- FIREBASE CONFIG ---
        const firebaseConfig = {
            apiKey: "AIzaSyA2818INoMI_LNIi3kTilRMUQXZ9S6yJjE",
            authDomain: "giaoandientu-7782.firebaseapp.com",
            projectId: "giaoandientu-7782",
            storageBucket: "giaoandientu-7782.firebasestorage.app",
            messagingSenderId: "585204135383",
            appId: "1:585204135383:web:78c7566be2083638290792",
            measurementId: "G-4F3MHQT43X"
        };

        // --- INITIALIZATION ---
        let app, auth, db, model, fastModel, analytics;
        try {
            app = initializeApp(firebaseConfig);
            analytics = getAnalytics(app); 
            auth = getAuth(app);
            db = getFirestore(app);
            const ai = getAI(app, { backend: new GoogleAIBackend() });
            
            model = getGenerativeModel(ai, { model: "gemini-2.5-flash" });
            fastModel = getGenerativeModel(ai, { model: "gemini-2.0-flash" });

        } catch(e) { 
            showError(`L·ªói kh·ªüi t·∫°o: ${e.message}. Vui l√≤ng ki·ªÉm tra c·∫•u h√¨nh Firebase.`); 
        }

        // --- DOM Elements ---
        const appContainer = document.getElementById('appContainer');
        const welcomeMessage = document.getElementById('welcomeMessage'), emailInput = document.getElementById('emailInput'), passwordInput = document.getElementById('passwordInput'), loginButton = document.getElementById('loginButton'), registerButton = document.getElementById('registerButton'), logoutButton = document.getElementById('logoutButton'), authError = document.getElementById('authError'), quizTypeSelect = document.getElementById('quizTypeSelect'), vocabModeContainer = document.getElementById('vocabModeContainer'), vocabModeSelect = document.getElementById('vocabModeSelect'), topicContainer = document.getElementById('topicContainer'), topicSelect = document.getElementById('topicSelect'), levelSelect = document.getElementById('levelSelect'), questionCountContainer = document.getElementById('questionCountContainer'), questionCountSelect = document.getElementById('questionCountSelect'), startQuizButton = document.getElementById('startQuizButton'), showHistoryButton = document.getElementById('showHistoryButton'), showNotebookButton = document.getElementById('showNotebookButton'), showLibraryButton = document.getElementById('showLibraryButton'), libraryList = document.getElementById('libraryList'), backToSetupFromLibrary = document.getElementById('backToSetupFromLibrary'), historyDashboard = document.getElementById('historyDashboard'), recommendationsContainer = document.getElementById('recommendationsContainer'), historyFilters = document.getElementById('historyFilters'), filterSkill = document.getElementById('filterSkill'), filterLevel = document.getElementById('filterLevel'), historyList = document.getElementById('historyList'), backToSetupFromHistory = document.getElementById('backToSetupFromHistory'), loadingTopic = document.getElementById('loadingTopic'), loadingTitle = document.getElementById('loadingTitle'), loadingMessage = document.getElementById('loadingMessage'), quizTitle = document.getElementById('quizTitle'), quizSubtitle = document.getElementById('quizSubtitle'), progress = document.getElementById('progress'), scoreEl = document.getElementById('score'), progressBar = document.getElementById('progressBar'), audioPlayerContainer = document.getElementById('audioPlayerContainer'), playAudioBtn = document.getElementById('playAudioBtn'), playIcon = document.getElementById('playIcon'), pauseIcon = document.getElementById('pauseIcon'), audioStatus = document.getElementById('audioStatus'), transcriptControls = document.getElementById('transcriptControls'), showTranscriptBtn = document.getElementById('showTranscriptBtn'), transcriptContainer = document.getElementById('transcriptContainer'), passageContainer = document.getElementById('passageContainer'), passageText = document.getElementById('passageText'), questionContainer = document.getElementById('questionContainer'), questionText = document.getElementById('questionText'), translateQuestionBtn = document.getElementById('translateQuestionBtn'), optionsContainer = document.getElementById('optionsContainer'), feedbackContainer = document.getElementById('feedbackContainer'), nextQuestionButton = document.getElementById('nextQuestionButton'), playAgainButton = document.getElementById('playAgainButton'), reviewAnswersButton = document.getElementById('reviewAnswersButton'), reviewList = document.getElementById('reviewList'), backToPreviousViewButton = document.getElementById('backToPreviousViewButton'), viewHistoryFromResultButton = document.getElementById('viewHistoryFromResultButton'), finalScore = document.getElementById('finalScore'), resultMessage = document.getElementById('resultMessage'), resultScoreContainer = document.getElementById('resultScoreContainer'), errorMessage = document.getElementById('errorMessage'), backToSetupButton = document.getElementById('backToSetupButton'), streakCount = document.getElementById('streakCount'), translationModal = document.getElementById('translationModal'), translationResult = document.getElementById('translationResult'), closeTranslationModal = document.getElementById('closeTranslationModal'), confirmModal = document.getElementById('confirmModal'), confirmTitle = document.getElementById('confirmTitle'), confirmMessage = document.getElementById('confirmMessage'), confirmCancelBtn = document.getElementById('confirmCancelBtn'), confirmOkBtn = document.getElementById('confirmOkBtn');
        const backToSetupFromWriting = document.getElementById('backToSetupFromWriting'), writingTopic = document.getElementById('writingTopic'), writingInput = document.getElementById('writingInput'), wordCount = document.getElementById('wordCount'), getFeedbackButton = document.getElementById('getFeedbackButton'), writingFeedbackContainer = document.getElementById('writingFeedbackContainer');
        const reinforceModal = document.getElementById('reinforceModal'), reinforceTitle = document.getElementById('reinforceTitle'), reinforceContent = document.getElementById('reinforceContent'), closeReinforceModal = document.getElementById('closeReinforceModal');
        const quickStartButton = document.getElementById('quickStartButton');
        const autoAdvanceCheckbox = document.getElementById('autoAdvanceCheckbox');
        const startPlacementTestButton = document.getElementById('startPlacementTestButton');
        const placementResultContainer = document.getElementById('placementResultContainer');
        const createPathButton = document.getElementById('createPathButton');
        const backToSetupFromPlacement = document.getElementById('backToSetupFromPlacement');
        const placementTestContainer = document.getElementById('placementTestContainer');
        const learningPathCTA = document.getElementById('learningPathCTA');
        const continuePathButton = document.getElementById('continuePathButton');
        const goalOptionsContainer = document.getElementById('goalOptionsContainer');
        const learningPathContainer = document.getElementById('learningPathContainer');
        const backToSetupFromPath = document.getElementById('backToSetupFromPath');
        const reinforcementReviewList = document.getElementById('reinforcementReviewList');
        const backToPathFromReinforcement = document.getElementById('backToPathFromReinforcement');
        const retryPathStepFromReinforcement = document.getElementById('retryPathStepFromReinforcement');
        const assessmentChoiceView = document.getElementById('assessment-choice-view');
        const startTraditionalTestButton = document.getElementById('startTraditionalTestButton');
        const startDiagnosticConversationButton = document.getElementById('startDiagnosticConversationButton');
        const backToSetupFromChoice = document.getElementById('backToSetupFromChoice');
        const conversationLog = document.getElementById('conversationLog');
        const conversationInputArea = document.getElementById('conversationInputArea');
        const micButton = document.getElementById('micButton');
        const conversationTextInput = document.getElementById('conversationTextInput');
        const sendTextButton = document.getElementById('sendTextButton');
        const endDiagnosticConversationButton = document.getElementById('endDiagnosticConversationButton');
        const diagnosticChartContainer = document.getElementById('diagnosticChartContainer');
        const diagnosticChartCanvas = document.getElementById('diagnosticChart');
        const customTopicContainer = document.getElementById('customTopicContainer');
        const customTopicInput = document.getElementById('customTopicInput');
        
        // Notebook v4 DOM Elements
        const backToSetupFromDecks = document.getElementById('backToSetupFromDecks');
        const showCreateDeckModalButton = document.getElementById('showCreateDeckModalButton');
        const deckListContainer = document.getElementById('deckListContainer');
        const deckDetailTitle = document.getElementById('deckDetailTitle');
        const backToDecksListButton = document.getElementById('backToDecksListButton');
        const quickLookupInput = document.getElementById('quickLookupInput');
        const quickLookupButton = document.getElementById('quickLookupButton');
        const quickLookupResult = document.getElementById('quickLookupResult');
        const deckSearchInput = document.getElementById('deckSearchInput');
        const selectAllWordsCheckbox = document.getElementById('selectAllWordsCheckbox');
        const deleteSelectedWordsButton = document.getElementById('deleteSelectedWordsButton');
        const deckWordList = document.getElementById('deckWordList');
        const reviewSelectedWordsButton = document.getElementById('reviewSelectedWordsButton');
        const createDeckModal = document.getElementById('createDeckModal');
        const newDeckNameInput = document.getElementById('newDeckNameInput');
        const cancelCreateDeckBtn = document.getElementById('cancelCreateDeckBtn');
        const confirmCreateDeckBtn = document.getElementById('confirmCreateDeckBtn');
        const wordInfoModal = document.getElementById('wordInfoModal');
        const wordInfoTitle = document.getElementById('wordInfoTitle');
        const wordInfoSpeakBtn = document.getElementById('wordInfoSpeakBtn');
        const wordInfoContent = document.getElementById('wordInfoContent');
        const deckSelectDropdown = document.getElementById('deckSelectDropdown');
        const saveWordToDeckBtn = document.getElementById('saveWordToDeckBtn');
        const closeWordInfoModal = document.getElementById('closeWordInfoModal');


        // App State
        let quizData = {};
        let currentQuestionIndex = 0;
        let score = 0;
        let userHistoryCache = []; 
        let sessionResults = [];
        let reviewCameFrom = 'result-view'; 
        let matchingState = { selectedWordEl: null, correctPairs: 0 };
        let autoAdvanceTimer = null;
        let currentQuizType = 'standard'; // 'standard', 'placement', 'path', 'diagnostic', 'review'
        let currentUserPath = null;
        let diagnosticConversationState = {};
        let recognition;
        let chartInstance;
        let notebookWords = new Set(); 
        let currentDeck = { id: null, name: null, words: [] }; // State for the currently viewed deck

        
        // --- Audio State & Setup ---
        const synth = window.speechSynthesis;
        let audioState = 'idle'; 
        let lastSpokenCharIndex = 0;
        let isPausedByUser = false;
        let soundEffects;

        function setupAudio() {
            if (soundEffects || typeof Tone === 'undefined') return;
            soundEffects = {
                correct: new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 } }).toDestination(),
                incorrect: new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.4, sustain: 0, release: 0.4 } }).toDestination(),
                click: new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 2, envelope: { attack: 0.0006, decay: 0.2, sustain: 0 } }).toDestination()
            };
        }
        document.body.addEventListener('click', setupAudio, { once: true });

        function playSound(type) {
            if (!soundEffects) return;
            try {
                if (Tone.context.state !== 'running') { Tone.context.resume(); }
                switch(type) {
                    case 'correct': soundEffects.correct.triggerAttackRelease("C5", "8n"); break;
                    case 'incorrect': soundEffects.incorrect.triggerAttackRelease("C3", "8n"); break;
                    case 'click': soundEffects.click.triggerAttackRelease("C2", "8n", Tone.now()); break;
                }
            } catch (e) { console.error("Sound effect error:", e); }
        }

        // --- Core Functions ---
        function showView(viewId) { 
            if (synth.speaking) { synth.cancel(); }
            clearTimeout(autoAdvanceTimer);
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active')); 
            document.getElementById(viewId).classList.add('active'); 
        }

        function showError(msg) { 
            errorMessage.textContent = msg; 
            showView('error-view'); 
        }

        // --- Improved Modal Functions ---
        function showModal(modalElement) {
            playSound('click');
            modalElement.classList.add('active');
        }

        function hideModal(modalElement) {
            modalElement.classList.remove('active');
        }

        function showConfirmModal(message, onConfirm, okText = 'X√≥a') {
            confirmMessage.textContent = message;
            confirmOkBtn.textContent = okText;
            showModal(confirmModal);

            const handleConfirm = () => {
                playSound('click');
                onConfirm();
                hideModal(confirmModal);
                confirmOkBtn.removeEventListener('click', handleConfirm);
                confirmCancelBtn.removeEventListener('click', hideConfirmModal);
            };
            
            const hideConfirmModal = () => {
                 hideModal(confirmModal);
                 confirmOkBtn.removeEventListener('click', handleConfirm);
            }

            confirmCancelBtn.addEventListener('click', hideConfirmModal, { once: true });
            confirmOkBtn.addEventListener('click', handleConfirm, { once: true });
        }

        // --- Auth & User State ---
        async function fetchAllUserWords() {
            if (!auth.currentUser) return;
            const wordsRef = collection(db, "users", auth.currentUser.uid, "vocabulary");
            const querySnapshot = await getDocs(query(wordsRef));
            notebookWords = new Set(querySnapshot.docs.map(doc => doc.data().word.toLowerCase()));
        }
        
        onAuthStateChanged(auth, async (user) => {
            if (user) { 
                welcomeMessage.textContent = `Ch√†o m·ª´ng, ${user.email}!`; 
                await updateUserStreak(user.uid); 
                await checkUserLearningPath(user.uid);
                await fetchAllUserWords();
                showView('setup-view'); 
            } else { 
                showView('auth-view'); 
                userHistoryCache = []; 
                currentUserPath = null;
                notebookWords.clear();
            }
        });

        async function checkUserLearningPath(userId) {
            const pathRef = doc(db, "learningPaths", userId);
            const docSnap = await getDoc(pathRef);
            if (docSnap.exists() && docSnap.data().status === 'active') {
                currentUserPath = { id: docSnap.id, ...docSnap.data() };
                placementTestContainer.classList.add('hidden');
                learningPathCTA.classList.remove('hidden');
            } else {
                currentUserPath = null;
                placementTestContainer.classList.remove('hidden');
                learningPathCTA.classList.add('hidden');
            }
        }

        async function updateUserStreak(userId) {
            const userRef = doc(db, "users", userId);
            const today = new Date().toISOString().slice(0, 10);
            try {
                const userDoc = await getDoc(userRef);
                let currentStreak = 0; let lastActivityDate = '';
                if (userDoc.exists()) { const userData = userDoc.data(); currentStreak = userData.currentStreak || 0; lastActivityDate = userData.lastActivityDate || ''; }
                if (lastActivityDate === today) { streakCount.textContent = currentStreak; return; }
                const yesterday = new Date(); yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayStr = yesterday.toISOString().slice(0, 10);
                if (lastActivityDate === yesterdayStr) { currentStreak++; } else { currentStreak = 1; }
                await setDoc(userRef, { lastActivityDate: today, currentStreak: currentStreak }, { merge: true });
                streakCount.textContent = currentStreak;
            } catch (error) { console.error("Error updating streak:", error); }
        }

        const handleAuthAction = async (action) => {
            playSound('click');
            const email = emailInput.value;
            const password = passwordInput.value; 
            authError.textContent = '';
            if (!email || !password) { 
                authError.textContent = 'Vui l√≤ng nh·∫≠p ƒë·ªß email v√† m·∫≠t kh·∫©u.'; 
                return; 
            }
            const button = action === 'login' ? loginButton : registerButton;
            const otherButton = action === 'login' ? registerButton : loginButton;
            const buttonText = button.querySelector('.btn-text');
            const spinner = button.querySelector('.spinner');
            
            buttonText.textContent = action === 'login' ? 'ƒêang ƒëƒÉng nh·∫≠p...' : 'ƒêang ƒëƒÉng k√Ω...';
            spinner.classList.remove('hidden'); 
            button.disabled = true; 
            otherButton.disabled = true;
            
            try {
                if (action === 'login') { 
                    await signInWithEmailAndPassword(auth, email, password); 
                } else {
                    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                    await setDoc(doc(db, "users", userCredential.user.uid), { 
                        email: userCredential.user.email, 
                        createdAt: serverTimestamp(), 
                        currentStreak: 0, 
                        lastActivityDate: '' 
                    });
                }
            } catch (error) { 
                authError.textContent = getFriendlyAuthError(error.code); 
            } finally {
                buttonText.textContent = action === 'login' ? 'ƒêƒÉng nh·∫≠p' : 'ƒêƒÉng k√Ω';
                spinner.classList.add('hidden'); 
                button.disabled = false; 
                otherButton.disabled = false;
            }
        };

        const handleLogout = async () => { 
            playSound('click');
            try { 
                await signOut(auth); 
            } catch (error) { 
                showError("ƒêƒÉng xu·∫•t th·∫•t b·∫°i."); 
            }
        };

        function getFriendlyAuthError(c) { 
            switch (c) { 
                case 'auth/invalid-email': return 'Email kh√¥ng h·ª£p l·ªá.'; 
                case 'auth/user-not-found': 
                case 'auth/wrong-password': return 'Email ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng.'; 
                case 'auth/email-already-in-use': return 'Email ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng.'; 
                case 'auth/weak-password': return 'M·∫≠t kh·∫©u qu√° y·∫øu.'; 
                default: return 'L·ªói x√°c th·ª±c.'; 
            } 
        }

        // --- AI & Quiz Generation ---
        function extractAndParseJson(rawText) {
            const regex = /```json\s*([\s\S]*?)\s*```/;
            const match = rawText.match(regex);
            let jsonString = (match && match[1]) ? match[1] : rawText;
            jsonString = jsonString.replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F]/g, '');
            try { return JSON.parse(jsonString); } 
            catch (error) { console.error("JSON Parse Error:", error, "String:", jsonString); return null; }
        }

        async function getTranslation(text) {
            try {
                const prompt = `Translate the following English text to Vietnamese. Provide only the Vietnamese translation, without any extra text or quotation marks: "${text}"`;
                const result = await fastModel.generateContent(prompt);
                const response = await result.response;
                return response.text();
            } catch (error) { console.error("Translation error:", error); return "Kh√¥ng th·ªÉ d·ªãch ƒë∆∞·ª£c."; }
        }

        function showTranslationModal(textPromise) {
            showModal(translationModal);
            translationResult.innerHTML = '<div class="spinner mx-auto"></div>';
            textPromise.then(translatedText => { translationResult.innerHTML = `<p class="text-lg">${translatedText}</p>`; });
        }
        
        // --- PROMPTS ---
        function getWordInfoPrompt(word) {
            return `Provide a simple Vietnamese definition, a simple English example sentence, and the IPA transcription for the word "${word}". You MUST wrap your entire response in a 'json' markdown code block.
            Example:
            \`\`\`json
            {
              "definition": "m·ªôt thi·∫øt b·ªã ƒëi·ªán t·ª≠ ƒë·ªÉ l∆∞u tr·ªØ v√† x·ª≠ l√Ω d·ªØ li·ªáu",
              "example": "I use my computer for work and study.",
              "ipa": "/k…ômÀàpjuÀêt…ôr/"
            }
            \`\`\``;
        }
        
        function getReviewQuizPrompt(wordList) {
            const wordsString = wordList.map(w => `"${w.word}"`).join(', ');
            return `You are an expert English teacher. Create a mixed vocabulary quiz with exactly ${wordList.length} questions to review the following list of words: ${wordsString}.
            For each word, create one question of a varied type (multiple choice, fill-in-the-blank, word formation). Do not use the same question type for all words.
            - For multiple choice, provide the full text of the correct answer in the "answer" field and a Vietnamese explanation.
            - For fill-in-the-blank, provide the sentence with "___" and the correct word as the "answer".
            - For word formation, provide the sentence with a blank, the base word in parentheses, and the correctly formed word as the "answer".
            
            You MUST wrap your entire response in a 'json' markdown code block. The structure MUST be a valid JSON array of question objects.
            Example:
            \`\`\`json
            [
              { "type": "multiple_choice", "question": "Which word means 'to build something'?", "options": ["construct", "destroy", "design", "draw"], "answer": "construct", "explanation": "Construct c√≥ nghƒ©a l√† x√¢y d·ª±ng." },
              { "type": "fill_in_the_blank", "question": "The company's annual ___ was impressive.", "answer": "revenue", "explanation": "Revenue l√† 'doanh thu'." }
            ]
            \`\`\``;
        }
        // Other prompts remain the same...
        function getPlacementTestPrompt() { return `You are an expert English assessment creator. Create a comprehensive placement test with exactly 12 multiple-choice questions to determine a user's CEFR level (from A2 to B2). The test MUST include: - 4 Grammar questions, with increasing difficulty (A2, B1, B1, B2). - 4 Vocabulary questions, with increasing difficulty (A2, B1, B1, B2) covering common topics. - 1 short reading passage (around 80-100 words, at a B1 level). - 4 multiple-choice questions based on the reading passage. For each question, provide one correct answer and three plausible distractors. The "answer" field MUST be the full text of the correct option. You MUST wrap your entire response in a 'json' markdown code block. The structure MUST be a valid JSON object with a "passage" key (which can be an empty string for non-reading questions) and a "questions" key containing an array of 12 question objects.`; }
        function getPlacementAnalysisPrompt(results) { const userAnswers = results.map(r => ({ question: r.question.question, userAnswer: r.userAnswer, correctAnswer: r.question.answer })); return `An English learner has just completed a placement test. Here are their results: ${JSON.stringify(userAnswers)}. Based on these answers, please perform the following tasks: 1.  Determine the user's approximate CEFR level (e.g., "A2", "B1", "B2"). 2.  Write a short, friendly analysis (2-3 sentences in Vietnamese) of their performance, highlighting one strength and one area for improvement. You MUST wrap your entire response in a 'json' markdown code block. The structure MUST be a valid JSON object with "level" and "analysis" keys.`; }
        function getLearningPathPrompt(placementResult, goal) { return `An English learner has the following profile: - CEFR Level determined by placement test: ${placementResult.level} - Placement test analysis: "${placementResult.analysis}" - Stated learning goal: "${goal}" Based on this profile, create a personalized learning path consisting of 10-15 sequential steps. Each step should be a specific, actionable learning unit. For each step, define its "type" ('vocabulary', 'grammar', 'reading', 'listening', 'writing', or 'review'), a "topic", a "level" (CEFR), and a short "description" in Vietnamese. The path should start with foundational topics based on the user's weaknesses and progressively build up towards their goal. Include 'review' steps periodically to reinforce learning. You MUST wrap your entire response in a 'json' markdown code block. The structure MUST be a valid JSON array of step objects.`; }
        function getDiagnosticAnalysisPrompt(conversationData) { const dataString = JSON.stringify(conversationData, null, 2); return `You are a master English language assessor AI. A user has just completed a diagnostic conversation. Here is the transcript and data collected: \`\`\`json ${dataString} \`\`\` Based on ALL the provided data, perform a holistic analysis. Your response MUST be a JSON object wrapped in a 'json' markdown code block with the following structure: 1.  "overallLevel": A string representing the user's overall CEFR level (e.g., "A2", "B1", "B2"). 2.  "skillsProfile": An object with scores from 0 to 100 for the following five skills: "pronunciation", "fluency", "listening", "vocabulary", "grammar". 3.  "analysis": A detailed, friendly analysis in VIETNAMESE (3-4 sentences).`; }
        function getFlashcardPrompt(level, topic, count) { return `You are an expert English teacher. Generate ${count} flashcards for an English learner at the ${level} CEFR level. The topic is "${topic}". For each card, provide the English "word", its IPA transcription in the "ipa" field, its Vietnamese "meaning", and an "example" sentence in English using the word. You MUST wrap your entire response in a 'json' markdown code block. The structure MUST be a valid JSON array of objects.`; }
        function getMatchingPrompt(level, topic, pairCount) { return `You are an expert English teacher. Generate a single 'matching' game question for an English learner at the ${level} CEFR level. The topic is "${topic}". The question object must have a "type" of "matching" and a "pairs" array containing ${pairCount} objects. Each object in the "pairs" array must have an English "word" and its Vietnamese "meaning". You MUST wrap your entire response in a 'json' markdown code block. The structure MUST be a valid JSON object inside a single-element array.`; }
        function getWordScramblePrompt(level, topic, count) { return `You are an expert English teacher. Generate ${count} 'word scramble' questions for an English learner at the ${level} CEFR level. The topic is "${topic}". For each question, provide a "clue" which is a helpful hint or definition IN VIETNAMESE, and the "answer" which is the single English word to be scrambled. The answer must not contain spaces. You MUST wrap your entire response in a 'json' markdown code block. The structure MUST be a valid JSON array of objects.`; }
        function getVocabularyPrompt(level, topic, count) { return `You are an expert English teacher. Generate ${count} multiple-choice vocabulary questions for an English learner at the ${level} CEFR level. The topic is "${topic}". For the "answer" field, you MUST provide the full text of the correct option. Provide one correct answer, three plausible distractors, and a brief, helpful explanation IN VIETNAMESE. You MUST wrap your entire response in a 'json' markdown code block. The structure MUST be a valid JSON array of objects.`; }
        function getFillInTheBlankPrompt(level, topic, count) { return `You are an expert English teacher. Generate ${count} 'fill-in-the-blank' vocabulary questions for an English learner at the ${level} CEFR level. The topic is "${topic}". For each item, provide a sentence with "___" and the correct "answer" word. Provide a brief, helpful explanation IN VIETNAMESE. You MUST wrap your entire response in a 'json' markdown code block. The structure MUST be a valid JSON array of objects.`; }
        function getWordFormationPrompt(level, topic, count) { return `You are an expert English teacher. Generate ${count} 'word-formation' questions for an English learner at the ${level} CEFR level. The topic is "${topic}". For each item, provide a sentence with a blank and a base word in parentheses. The "answer" MUST be the single, correctly formed word. Provide a brief, helpful explanation IN VIETNAMESE. You MUST wrap your entire response in a 'json' markdown code block. The structure MUST be a valid JSON array of objects.`; }
        function getReadingPrompt(level, topic, count) { return `You are an expert English teacher. Create a reading comprehension quiz for a ${level} CEFR level learner on the topic of "${topic}". You MUST adhere to the following language rules STRICTLY: - The "passage" MUST be in ENGLISH. - Each object in the "questions" array MUST have a "question" and an "options" array. Both "question" text and all strings within the "options" array MUST be in ENGLISH. - The "answer" field MUST be the full text of the correct option, in ENGLISH. - The "explanation" field is the ONLY field that MUST be in VIETNAMESE. Generate one short reading passage (100-150 words) and ${count} multiple-choice questions. You MUST wrap your entire response in a 'json' markdown code block. The structure MUST be a valid JSON object.`; }
        function getGrammarPrompt(level, topic, count) { return `You are an expert English grammar teacher. Generate ${count} multiple-choice grammar questions for a ${level} CEFR level learner. Each question MUST specifically test the grammar point: "${topic}". If the topic is "General", you can test any common grammar point. For the "answer" field, you MUST provide the full text of the correct option. Provide one correct answer, three plausible distractors, and a brief, helpful explanation IN VIETNAMESE. You MUST wrap your entire response in a 'json' markdown code block. The structure MUST be a valid JSON array of objects.`; }
        function getListeningPrompt(level, topic, count) { return `You are an expert English teacher. Create a listening comprehension quiz. 1. Generate one short monologue or dialogue (50-80 words). The topic is "${topic}" and for a ${level} CEFR level learner. 2. Based on the script, generate ${count} multiple-choice questions. 3. For each question, provide one correct answer, three plausible distractors, and a brief, helpful explanation IN VIETNAMESE. The "answer" field MUST be the full text of the correct option. You MUST wrap your entire response in a 'json' markdown code block. The structure MUST be a valid JSON object.`; }
        function getWritingTopicPrompt(level, topic) { return `You are an English teacher. Generate a single, engaging writing topic for an English learner at the ${level} CEFR level. The topic should be related to "${topic}". The topic should be a question or a statement to respond to. Provide only the topic text, without any extra labels or quotation marks.`; }
        function getWritingFeedbackPrompt(level, topic, userText) { return `You are an expert English writing evaluator. A student at the ${level} CEFR level has written the following text about the topic "${topic}". Student's text: """ ${userText} """ Please provide feedback in Vietnamese. You MUST wrap your entire response in a 'json' markdown code block. The JSON object must have the following structure: 1. "overallFeedback": A general comment in Vietnamese (2-3 sentences). 2. "score": An integer score from 0 to 100. 3. "correctedTextHTML": The student's original text with corrections. Use "<del>" and "<ins>" tags. 4. "detailedFeedback": An array of objects, each explaining a specific mistake.`; }
        function getReinforcementPrompt(question, userAnswer) { const level = quizData.level; const questionText = question.question || question.clue; const options = question.options ? JSON.stringify(question.options) : 'N/A'; return `You are an expert and friendly English tutor AI. A student has made a mistake on a quiz. Your task is to provide a comprehensive, easy-to-understand lesson to help them master the concept they got wrong. The student is at the ${level} CEFR level. Quiz question: - Question: "${questionText}" - Options (if any): ${options} - Correct Answer: "${question.answer}" - Student's Incorrect Answer: "${userAnswer}" Please generate a lesson in Vietnamese. You MUST wrap your entire response in a 'json' markdown code block. The JSON object must have a "conceptTitle", "mistakeAnalysis", "conceptExplanation", "examples" array, and "practiceTip".`; }

        // --- Word Lookup & Rendering ---
        function renderTextWithClickableWords(container, text) {
            container.innerHTML = '';
            const words = text.split(/(\s+|[.,?!;:()])/); // Split by spaces and punctuation
            words.forEach(word => {
                const cleanedWord = word.trim().toLowerCase().replace(/[^a-z'-]/g, '');
                if (cleanedWord.length > 1) { // Only make actual words clickable
                    const span = document.createElement('span');
                    span.textContent = word;
                    span.className = 'lookup-word';
                    if (notebookWords.has(cleanedWord)) {
                        span.classList.add('saved-word-highlight');
                    }
                    container.appendChild(span);
                } else {
                    container.appendChild(document.createTextNode(word));
                }
            });
        }

        async function showWordInfo(word) {
            const cleanedWord = word.trim().toLowerCase().replace(/[^a-z'-]/g, '');
            if (!cleanedWord) return;

            showModal(wordInfoModal);
            wordInfoTitle.textContent = cleanedWord;
            wordInfoContent.innerHTML = '<div class="spinner mx-auto"></div>';
            saveWordToDeckBtn.disabled = true;
            wordInfoSpeakBtn.onclick = () => playSpeech(cleanedWord);

            try {
                // Fetch user decks to populate dropdown
                const decksRef = collection(db, "users", auth.currentUser.uid, "notebookDecks");
                const decksSnapshot = await getDocs(query(decksRef));
                deckSelectDropdown.innerHTML = '';
                if (decksSnapshot.empty) {
                    deckSelectDropdown.innerHTML = '<option value="">Vui l√≤ng t·∫°o m·ªôt b·ªô th·∫ª tr∆∞·ªõc</option>';
                } else {
                    decksSnapshot.docs.forEach(doc => {
                        deckSelectDropdown.innerHTML += `<option value="${doc.id}">${doc.data().name}</option>`;
                    });
                }

                // Fetch word info from AI
                const prompt = getWordInfoPrompt(cleanedWord);
                const result = await fastModel.generateContent(prompt);
                const response = await result.response;
                const rawText = response.text();
                const wordInfo = extractAndParseJson(rawText);

                if (!wordInfo || typeof wordInfo.definition !== 'string' || typeof wordInfo.example !== 'string') {
                    throw new Error("AI did not return the expected format.");
                }

                wordInfoContent.innerHTML = `
                    <p class="text-lg text-slate-500">${wordInfo.ipa || ''}</p>
                    <p><b class="font-semibold text-slate-700">Nghƒ©a:</b> ${wordInfo.definition}</p>
                    <p class="mt-2"><b class="font-semibold text-slate-700">V√≠ d·ª•:</b> <i class="text-slate-600">"${wordInfo.example}"</i></p>
                `;
                
                saveWordToDeckBtn.disabled = decksSnapshot.empty;
                saveWordToDeckBtn.textContent = 'L∆∞u v√†o b·ªô th·∫ª';
                saveWordToDeckBtn.onclick = () => {
                    const selectedDeckId = deckSelectDropdown.value;
                    if (!selectedDeckId) {
                        alert("Vui l√≤ng ch·ªçn m·ªôt b·ªô th·∫ª.");
                        return;
                    }
                    saveWordToNotebook(cleanedWord, wordInfo, selectedDeckId);
                    saveWordToDeckBtn.textContent = 'ƒê√£ l∆∞u th√†nh c√¥ng!';
                    saveWordToDeckBtn.disabled = true;
                    notebookWords.add(cleanedWord);
                    // Highlight the word in the UI
                    document.querySelectorAll('.lookup-word').forEach(span => {
                        if (span.textContent.trim().toLowerCase().replace(/[^a-z'-]/g, '') === cleanedWord) {
                            span.classList.add('saved-word-highlight');
                        }
                    });
                    setTimeout(() => hideModal(wordInfoModal), 1000);
                };

            } catch (error) {
                console.error("Word Lookup Error:", error);
                wordInfoContent.innerHTML = `<p class="text-red-500">R·∫•t ti·∫øc, kh√¥ng th·ªÉ tra c·ª©u t·ª´ n√†y v√†o l√∫c n√†y. Vui l√≤ng th·ª≠ l·∫°i sau.</p>`;
            }
        }

        // --- Notebook v4 Functions ---

        // Show the main view with all user's decks
        async function showNotebookDecks() {
            if (!auth.currentUser) { showError("B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ xem s·ªï tay."); return; }
            showView('notebook-decks-view');
            deckListContainer.innerHTML = '<div class="spinner mx-auto col-span-full"></div>';

            try {
                const decksRef = collection(db, "users", auth.currentUser.uid, "notebookDecks");
                const q = query(decksRef);
                const querySnapshot = await getDocs(q);

                const wordCounts = await getWordCountsPerDeck();

                if (querySnapshot.empty) {
                    deckListContainer.innerHTML = '<p class="text-center text-slate-500 col-span-full">B·∫°n ch∆∞a c√≥ b·ªô th·∫ª n√†o. H√£y t·∫°o m·ªôt b·ªô th·∫ª m·ªõi ƒë·ªÉ b·∫Øt ƒë·∫ßu!</p>';
                    return;
                }

                deckListContainer.innerHTML = '';
                querySnapshot.docs
                    .sort((a, b) => (b.data().createdAt?.seconds || 0) - (a.data().createdAt?.seconds || 0))
                    .forEach(doc => {
                        const deckData = doc.data();
                        const deckId = doc.id;
                        const count = wordCounts[deckId] || 0;
                        const card = document.createElement('div');
                        card.className = 'deck-card bg-teal-50 p-4 rounded-lg border border-teal-200 hover:shadow-md hover:border-teal-400 transition cursor-pointer flex flex-col justify-between';
                        card.dataset.deckId = deckId;
                        card.dataset.deckName = deckData.name;
                        
                        card.innerHTML = `
                            <div>
                                <h4 class="text-xl font-bold text-teal-800">${deckData.name}</h4>
                                <p class="text-sm text-slate-500">${count} t·ª´</p>
                            </div>
                            <div class="text-right mt-4">
                                <button class="delete-deck-btn text-red-400 hover:text-red-600 text-sm font-semibold" data-deck-id="${deckId}">X√≥a</button>
                            </div>
                        `;
                        deckListContainer.appendChild(card);
                    });
            } catch (error) {
                console.error("Error loading notebook decks:", error);
                deckListContainer.innerHTML = '<p class="text-center text-red-500 col-span-full">Kh√¥ng th·ªÉ t·∫£i c√°c b·ªô th·∫ª.</p>';
            }
        }
        
        // Helper to get word counts for all decks at once
        async function getWordCountsPerDeck() {
            if (!auth.currentUser) return {};
            const wordsRef = collection(db, "users", auth.currentUser.uid, "vocabulary");
            const snapshot = await getDocs(wordsRef);
            const counts = {};
            snapshot.forEach(doc => {
                const deckId = doc.data().deckId;
                if (deckId) {
                    counts[deckId] = (counts[deckId] || 0) + 1;
                }
            });
            return counts;
        }

        // Show the details view for a single deck
        async function showDeckDetails(deckId, deckName) {
            currentDeck.id = deckId;
            currentDeck.name = deckName;
            showView('deck-details-view');
            deckDetailTitle.textContent = deckName;
            deckWordList.innerHTML = '<div class="spinner mx-auto"></div>';
            quickLookupInput.value = '';
            quickLookupResult.innerHTML = '';
            deckSearchInput.value = '';

            try {
                const wordsRef = collection(db, "users", auth.currentUser.uid, "vocabulary");
                const q = query(wordsRef, where("deckId", "==", deckId));
                const querySnapshot = await getDocs(q);

                currentDeck.words = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderDeckWordList(currentDeck.words);

            } catch (error) {
                console.error(`Error loading words for deck ${deckId}:`, error);
                deckWordList.innerHTML = '<p class="text-center text-red-500">Kh√¥ng th·ªÉ t·∫£i danh s√°ch t·ª´.</p>';
            }
        }

        // Render the list of words within a deck
        function renderDeckWordList(words) {
            deckWordList.innerHTML = '';
            if (words.length === 0) {
                deckWordList.innerHTML = '<p class="text-center text-slate-500 p-4">B·ªô th·∫ª n√†y ch∆∞a c√≥ t·ª´ n√†o. H√£y d√πng box tra c·ª©u ·ªü tr√™n ƒë·ªÉ th√™m t·ª´ m·ªõi!</p>';
                return;
            }
            
            words.sort((a, b) => (b.addedAt?.seconds || 0) - (a.addedAt?.seconds || 0))
                 .forEach(wordData => {
                const item = document.createElement('div');
                item.className = 'p-3 border rounded-lg bg-white flex items-center gap-4';
                item.innerHTML = `
                    <input type="checkbox" class="word-checkbox h-5 w-5 rounded border-gray-300 text-teal-600 focus:ring-teal-500 flex-shrink-0" data-word-id="${wordData.id}">
                    <div class="flex-grow">
                        <div class="flex items-center gap-2">
                            <b class="text-lg text-slate-800 capitalize">${wordData.word}</b>
                            <span class="text-sm text-slate-500">${wordData.ipa || ''}</span>
                        </div>
                        <p class="text-sm text-slate-600">${wordData.definition}</p>
                    </div>
                    <button class="speak-btn p-2 rounded-full hover:bg-sky-100 flex-shrink-0" onclick="window.playSpeech('${wordData.word}')">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-sky-600"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon></svg>
                    </button>
                `;
                deckWordList.appendChild(item);
            });
            updateReviewButtonState();
        }
        
        // Handle creating a new deck
        async function handleCreateDeck() {
            const deckName = newDeckNameInput.value.trim();
            if (!deckName) {
                alert("Vui l√≤ng nh·∫≠p t√™n cho b·ªô th·∫ª.");
                return;
            }
            if (!auth.currentUser) return;

            try {
                const decksRef = collection(db, "users", auth.currentUser.uid, "notebookDecks");
                await addDoc(decksRef, {
                    name: deckName,
                    createdAt: serverTimestamp()
                });
                newDeckNameInput.value = '';
                hideModal(createDeckModal);
                await showNotebookDecks(); // Refresh the list
            } catch (error) {
                console.error("Error creating deck:", error);
                alert("ƒê√£ c√≥ l·ªói x·∫£y ra khi t·∫°o b·ªô th·∫ª.");
            }
        }
        
        // Handle deleting a deck and all its words
        async function handleDeleteDeck(deckId) {
            if (!auth.currentUser || !deckId) return;

            showConfirmModal("B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a b·ªô th·∫ª n√†y? T·∫•t c·∫£ c√°c t·ª´ trong ƒë√≥ c≈©ng s·∫Ω b·ªã x√≥a vƒ©nh vi·ªÖn.", async () => {
                try {
                    const batch = writeBatch(db);

                    // Find all words in the deck to delete
                    const wordsRef = collection(db, "users", auth.currentUser.uid, "vocabulary");
                    const q = query(wordsRef, where("deckId", "==", deckId));
                    const wordsSnapshot = await getDocs(q);
                    wordsSnapshot.forEach(doc => {
                        batch.delete(doc.ref);
                    });

                    // Delete the deck itself
                    const deckRef = doc(db, "users", auth.currentUser.uid, "notebookDecks", deckId);
                    batch.delete(deckRef);

                    await batch.commit();
                    await showNotebookDecks(); // Refresh the list
                } catch (error) {
                    console.error("Error deleting deck:", error);
                    alert("ƒê√£ c√≥ l·ªói x·∫£y ra khi x√≥a b·ªô th·∫ª.");
                }
            });
        }
        
        // Handle deleting selected words from a deck
        async function handleDeleteSelectedWords() {
            if (!auth.currentUser || !currentDeck.id) return;

            const selectedWords = Array.from(deckWordList.querySelectorAll('.word-checkbox:checked'))
                                      .map(cb => cb.dataset.wordId);
            
            if (selectedWords.length === 0) {
                alert("Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt t·ª´ ƒë·ªÉ x√≥a.");
                return;
            }

            showConfirmModal(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a ${selectedWords.length} t·ª´ ƒë√£ ch·ªçn?`, async () => {
                try {
                    const batch = writeBatch(db);
                    selectedWords.forEach(wordId => {
                        const wordRef = doc(db, "users", auth.currentUser.uid, "vocabulary", wordId);
                        batch.delete(wordRef);
                    });
                    await batch.commit();
                    await showDeckDetails(currentDeck.id, currentDeck.name); // Refresh view
                } catch (error) {
                    console.error("Error deleting selected words:", error);
                    alert("ƒê√£ c√≥ l·ªói x·∫£y ra khi x√≥a t·ª´.");
                }
            });
        }

        // Handle the quick lookup and save feature
        async function handleQuickLookupAndSave() {
            const wordToLookup = quickLookupInput.value.trim();
            if (!wordToLookup) return;
            if (!currentDeck.id) {
                showError("L·ªói: Kh√¥ng c√≥ b·ªô th·∫ª n√†o ƒë∆∞·ª£c ch·ªçn.");
                return;
            }
            
            const button = quickLookupButton;
            const buttonText = button.querySelector('.btn-text');
            const spinner = button.querySelector('.spinner');
            
            buttonText.textContent = 'ƒêang tra...';
            spinner.classList.remove('hidden'); 
            button.disabled = true;

            try {
                const prompt = getWordInfoPrompt(wordToLookup);
                const result = await fastModel.generateContent(prompt);
                const response = await result.response;
                const wordInfo = extractAndParseJson(response.text());

                if (!wordInfo || !wordInfo.definition) {
                    throw new Error("AI kh√¥ng tr·∫£ v·ªÅ d·ªØ li·ªáu h·ª£p l·ªá.");
                }

                quickLookupResult.innerHTML = `
                    <div class="p-3 bg-green-100 border border-green-300 rounded-lg">
                        <p>ƒê√£ th√™m: <b class="capitalize">${wordToLookup}</b> - ${wordInfo.definition}</p>
                    </div>
                `;
                await saveWordToNotebook(wordToLookup, wordInfo, currentDeck.id);
                await showDeckDetails(currentDeck.id, currentDeck.name); // Refresh list
                quickLookupInput.value = '';

            } catch (error) {
                console.error("Quick lookup error:", error);
                quickLookupResult.innerHTML = `<p class="text-red-500">Kh√¥ng th·ªÉ tra c·ª©u t·ª´ "${wordToLookup}". Vui l√≤ng th·ª≠ l·∫°i.</p>`;
            } finally {
                buttonText.textContent = 'Tra c·ª©u & Th√™m';
                spinner.classList.add('hidden'); 
                button.disabled = false;
            }
        }

        // Save a word to a specific deck
        async function saveWordToNotebook(word, wordInfo, deckId) {
            if (!auth.currentUser) return;
            const cleanedWord = word.toLowerCase();
            
            const notebookRef = collection(db, "users", auth.currentUser.uid, "vocabulary");
            try {
                await addDoc(notebookRef, {
                    word: cleanedWord, 
                    deckId: deckId,
                    definition: wordInfo.definition || 'Ch∆∞a c√≥ gi·∫£i th√≠ch.',
                    example: wordInfo.example || 'Ch∆∞a c√≥ c√¢u v√≠ d·ª•.',
                    ipa: wordInfo.ipa || '',
                    addedAt: serverTimestamp()
                });
                notebookWords.add(cleanedWord); // Update global cache
            } catch (error) { 
                console.error("Error saving word:", error); 
                throw error; // Propagate error for handling in UI
            }
        }
        
        function updateReviewButtonState() {
            const selectedCount = deckWordList.querySelectorAll('.word-checkbox:checked').length;
            if (selectedCount > 0) {
                reviewSelectedWordsButton.disabled = false;
                reviewSelectedWordsButton.textContent = `√în t·∫≠p (${selectedCount} t·ª´)`;
                deleteSelectedWordsButton.disabled = false;
            } else {
                reviewSelectedWordsButton.disabled = true;
                reviewSelectedWordsButton.textContent = `√în t·∫≠p (0 t·ª´)`;
                deleteSelectedWordsButton.disabled = true;
            }
        }
        
        async function startReviewFromDeck() {
            const selectedCheckboxes = Array.from(deckWordList.querySelectorAll('.word-checkbox:checked'));
            const selectedWordIds = new Set(selectedCheckboxes.map(cb => cb.dataset.wordId));
            
            if (selectedWordIds.size === 0) {
                alert("Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt t·ª´ ƒë·ªÉ √¥n t·∫≠p.");
                return;
            }

            const wordsToReview = currentDeck.words.filter(word => selectedWordIds.has(word.id));
            
            currentQuizType = 'review';
            sessionResults = [];
            
            quizData = { 
                topic: `√în t·∫≠p: ${currentDeck.name}`, 
                level: "Mixed", 
                quizType: "review", 
                count: wordsToReview.length 
            };
            
            loadingTitle.textContent = 'ƒêang t·∫°o b√†i √¥n t·∫≠p...';
            loadingMessage.textContent = `AI ƒëang chu·∫©n b·ªã c√°c c√¢u h·ªèi ƒë·ªÉ b·∫°n √¥n t·∫≠p ${wordsToReview.length} t·ª´ ƒë√£ ch·ªçn.`;
            showView('loading-view');
            
            try {
                const prompt = getReviewQuizPrompt(wordsToReview);
                const result = await model.generateContent(prompt);
                const response = await result.response;
                const parsedData = extractAndParseJson(response.text());

                if (!parsedData || !Array.isArray(parsedData) || parsedData.length === 0) {
                    throw new Error("AI did not return a valid review quiz.");
                }
                
                quizData.raw = parsedData;
                currentQuestionIndex = 0; 
                score = 0;
                
                renderQuiz();
                showView('quiz-view');
            } catch (error) {
                showError(`Kh√¥ng th·ªÉ t·∫°o b√†i √¥n t·∫≠p. L·ªói: ${error.message}.`);
            }
        }


        // --- Quiz & Writing Lifecycle ---
        async function startPractice() {
            playSound('click');
            const quizType = quizTypeSelect.value;
            if (quizType === 'writing') {
                await startWritingPractice();
            } else {
                await startQuiz();
            }
        }
        
        async function quickStartPractice() {
            playSound('click');
            const quickStartSettings = {
                type: 'vocabulary',
                topic: 'Daily Life',
                level: levelSelect.value,
                count: 5,
                isRetry: false
            };
            await startQuiz(quickStartSettings);
        }

        async function startWritingPractice(settings = null) {
            currentQuizType = settings ? 'path' : 'standard';
            const level = settings ? settings.level : levelSelect.value;
            let topic;
            if (settings) {
                topic = settings.topic;
            } else {
                if (topicSelect.value === 'custom') {
                    topic = customTopicInput.value.trim();
                    if (!topic) {
                        alert("Vui l√≤ng nh·∫≠p ch·ªß ƒë·ªÅ t√πy ch·ªânh c·ªßa b·∫°n.");
                        return;
                    }
                } else {
                    topic = topicSelect.value;
                }
            }
            
            quizData = { topic, level, quizType: 'writing' };

            showView('loading-view');
            loadingTitle.textContent = 'ƒêang t·∫°o ch·ªß ƒë·ªÅ...';
            loadingMessage.textContent = `AI ƒëang nghƒ© ra m·ªôt ch·ªß ƒë·ªÅ Luy·ªán Vi·∫øt th√∫ v·ªã v·ªÅ "${topic}" cho b·∫°n.`;
            try {
                const prompt = getWritingTopicPrompt(level, topic);
                const result = await model.generateContent(prompt);
                const response = await result.response;
                const topicText = response.text();

                writingTopic.textContent = topicText;
                writingInput.value = '';
                wordCount.textContent = '0 t·ª´';
                writingFeedbackContainer.classList.add('hidden');
                writingFeedbackContainer.innerHTML = '';
                getFeedbackButton.disabled = false;
                writingInput.disabled = false;
                
                showView('writing-view');
            } catch (error) {
                showError(`Kh√¥ng th·ªÉ t·∫°o ch·ªß ƒë·ªÅ luy·ªán vi·∫øt. L·ªói: ${error.message}.`);
            }
        }

        async function getWritingFeedback() {
            playSound('click');
            const userText = writingInput.value;
            if (userText.trim().split(/\s+/).length < 10) {
                alert("Vui l√≤ng vi·∫øt √≠t nh·∫•t 10 t·ª´ ƒë·ªÉ nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi ch·∫•t l∆∞·ª£ng.");
                return;
            }

            const button = getFeedbackButton;
            const buttonText = button.querySelector('.btn-text');
            const spinner = button.querySelector('.spinner');
            
            buttonText.textContent = 'AI ƒëang ph√¢n t√≠ch...';
            spinner.classList.remove('hidden'); 
            button.disabled = true; 
            writingInput.disabled = true;

            try {
                const prompt = getWritingFeedbackPrompt(quizData.level, quizData.topic, userText);
                const result = await model.generateContent(prompt);
                const response = await result.response;
                const feedbackData = extractAndParseJson(response.text());

                if (!feedbackData) {
                    throw new Error("AI kh√¥ng tr·∫£ v·ªÅ ph·∫£n h·ªìi h·ª£p l·ªá. Vui l√≤ng th·ª≠ l·∫°i.");
                }

                displayWritingFeedback(feedbackData);
                writingFeedbackContainer.classList.remove('hidden');

                if (auth.currentUser) {
                    if (currentQuizType === 'path') {
                        await handlePathStepCompletion(feedbackData.score, 100);
                    } else {
                         await saveWritingResult(userText, feedbackData);
                    }
                }

            } catch (error) {
                showError(`Kh√¥ng th·ªÉ nh·∫≠n ph·∫£n h·ªìi. L·ªói: ${error.message}.`);
            } finally {
                buttonText.textContent = 'Nh·∫≠n ph·∫£n h·ªìi t·ª´ AI';
                spinner.classList.add('hidden'); 
            }
        }
        
        function displayWritingFeedback(data) {
            writingFeedbackContainer.innerHTML = `
                <div class="bg-sky-100 border-2 border-sky-300 rounded-xl p-6 text-center">
                    <p class="text-2xl font-semibold mb-2">ƒêi·ªÉm c·ªßa b·∫°n</p>
                    <p class="text-6xl font-bold text-sky-600">${data.score} / 100</p>
                </div>
                <div class="bg-slate-50 p-4 rounded-lg border border-slate-200">
                    <h4 class="text-lg font-bold text-slate-800 mb-2">Nh·∫≠n x√©t chung</h4>
                    <p class="text-slate-700">${data.overallFeedback}</p>
                </div>
                <div class="bg-slate-50 p-4 rounded-lg border border-slate-200">
                    <h4 class="text-lg font-bold text-slate-800 mb-2">B√†i vi·∫øt ƒë√£ s·ª≠a</h4>
                    <p class="text-lg leading-relaxed">${data.correctedTextHTML}</p>
                </div>
                <div class="bg-slate-50 p-4 rounded-lg border border-slate-200">
                    <h4 class="text-lg font-bold text-slate-800 mb-3">Ph√¢n t√≠ch chi ti·∫øt</h4>
                    <div class="space-y-3">
                        ${data.detailedFeedback.map(item => `
                            <div class="p-3 rounded-md bg-white border">
                                <p class="font-semibold text-slate-700"><span class="text-sm font-bold py-0.5 px-2 rounded-full bg-${getFeedbackColor(item.type)}-200 text-${getFeedbackColor(item.type)}-800">${item.type}</span></p>
                                <p class="text-red-600 mt-2">L·ªói: <span class="font-mono bg-red-100 p-1 rounded text-sm">"${item.mistake}"</span></p>
                                <p class="text-green-600">S·ª≠a th√†nh: <span class="font-mono bg-green-100 p-1 rounded text-sm">"${item.correction}"</span></p>
                                <p class="text-slate-600 mt-2 text-sm"><i>${item.explanation}</i></p>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function getFeedbackColor(type) {
            switch(type.toLowerCase()) {
                case 'grammar': return 'sky';
                case 'spelling': return 'amber';
                case 'punctuation': return 'violet';
                case 'vocabulary choice': return 'emerald';
                case 'style': return 'rose';
                default: return 'slate';
            }
        }

        // --- Learning Path & Quiz Lifecycle ---
        async function startPlacementTest() {
            currentQuizType = 'placement';
            sessionResults = []; 
            quizData = { topic: "Placement Test", level: "Mixed", quizType: "placement", count: 12 };
            loadingTitle.textContent = 'ƒêang t·∫°o b√†i ki·ªÉm tra...';
            loadingMessage.textContent = `AI ƒëang chu·∫©n b·ªã B√†i ki·ªÉm tra tr√¨nh ƒë·ªô cho b·∫°n.`;
            showView('loading-view');
            try {
                const prompt = getPlacementTestPrompt();
                const result = await model.generateContent(prompt);
                const response = await result.response;
                const parsedData = extractAndParseJson(response.text());
                if (!parsedData || !parsedData.questions) throw new Error("AI did not return a valid placement test.");
                
                quizData.raw = parsedData;
                currentQuestionIndex = 0; score = 0;
                
                renderQuiz();
                showView('quiz-view');
            } catch (error) {
                showError(`Kh√¥ng th·ªÉ t·∫°o b√†i ki·ªÉm tra tr√¨nh ƒë·ªô. L·ªói: ${error.message}.`);
            }
        }

        async function startQuiz(settings = null) {
            if (!settings) currentQuizType = 'standard';
            sessionResults = [];
            const quizType = settings ? settings.type : quizTypeSelect.value;
            const vocabMode = vocabModeSelect.value;
            const level = settings ? settings.level : levelSelect.value;
            const count = settings ? (settings.count || 5) : questionCountSelect.value;

            let topic;
            if (settings) {
                topic = settings.topic;
            } else {
                const isTopicBased = quizType === 'vocabulary' || quizType === 'reading' || quizType === 'listening';
                if (isTopicBased) {
                    if (topicSelect.value === 'custom') {
                        topic = customTopicInput.value.trim();
                        if (!topic) {
                            alert("Vui l√≤ng nh·∫≠p ch·ªß ƒë·ªÅ t√πy ch·ªânh c·ªßa b·∫°n.");
                            return;
                        }
                    } else {
                        topic = topicSelect.value;
                    }
                } else {
                    topic = 'General';
                }
            }
            
            quizData = { topic, level, quizType, vocabMode, count };
            loadingTitle.textContent = 'ƒêang t·∫°o b√†i ki·ªÉm tra...';
            loadingMessage.textContent = `AI ƒëang chu·∫©n b·ªã c√°c c√¢u h·ªèi v·ªÅ ch·ªß ƒë·ªÅ ${topic} cho b·∫°n. Vui l√≤ng ch·ªù!`;
            showView('loading-view');
            try {
                let prompt;
                if (quizType === 'vocabulary' || quizType === 'review') { // 'review' uses vocabulary prompts
                    switch(vocabMode) {
                        case 'fill_in_the_blank': prompt = getFillInTheBlankPrompt(level, topic, count); break;
                        case 'word_formation': prompt = getWordFormationPrompt(level, topic, count); break;
                        case 'word_scramble': prompt = getWordScramblePrompt(level, topic, count); break;
                        case 'matching': prompt = getMatchingPrompt(level, topic, count); break; 
                        case 'flashcard': prompt = getFlashcardPrompt(level, topic, count); break;
                        case 'multiple_choice':
                        default: prompt = getVocabularyPrompt(level, topic, count);
                    }
                }
                else if (quizType === 'reading') prompt = getReadingPrompt(level, topic, 3);
                else if (quizType === 'grammar') prompt = getGrammarPrompt(level, topic, count);
                else if (quizType === 'listening') prompt = getListeningPrompt(level, topic, 3);
                
                const result = await model.generateContent(prompt);
                const response = await result.response;
                const parsedData = extractAndParseJson(response.text());
                if (!parsedData) throw new Error("AI did not return valid JSON data.");
                
                quizData.raw = parsedData;
                currentQuestionIndex = 0; score = 0;
                
                if (currentQuizType === 'standard' && !settings?.isRetry) { saveQuizToLibrary(quizData); }

                renderQuiz();
                showView('quiz-view');
            } catch (error) {
                showError(`Kh√¥ng th·ªÉ t·∫°o b√†i ki·ªÉm tra. L·ªói: ${error.message}.`);
            }
        }
        
        function renderQuiz() {
            const isReading = quizData.quizType === 'reading' || (currentQuizType === 'placement' && quizData.raw.passage);
            const isListening = quizData.quizType === 'listening';
            const questions = quizData.raw.questions || (Array.isArray(quizData.raw) ? quizData.raw : []);
            const total = questions.length;
            
            if (currentQuizType === 'placement') {
                quizTitle.textContent = "B√†i ki·ªÉm tra tr√¨nh ƒë·ªô";
                quizSubtitle.textContent = "Ho√†n th√†nh t·∫•t c·∫£ c√¢u h·ªèi ƒë·ªÉ x√°c ƒë·ªãnh nƒÉng l·ª±c c·ªßa b·∫°n.";
            } else if (currentQuizType === 'path') {
                const step = currentUserPath.path[currentUserPath.currentStep];
                quizTitle.textContent = `L·ªô tr√¨nh: ${step.description}`;
                quizSubtitle.textContent = `B∆∞·ªõc ${currentUserPath.currentStep + 1} / ${currentUserPath.path.length}`;
            } else if (currentQuizType === 'review') {
                 quizTitle.textContent = "B√†i √¥n t·∫≠p";
                 quizSubtitle.textContent = quizData.topic;
            }
            else {
                const typeMap = { vocabulary: 'Luy·ªán t·∫≠p T·ª´ v·ª±ng', reading: 'Luy·ªán t·∫≠p ƒê·ªçc hi·ªÉu', grammar: 'Luy·ªán t·∫≠p Ng·ªØ ph√°p', listening: 'Luy·ªán t·∫≠p Nghe hi·ªÉu' };
                const modeMap = { multiple_choice: 'Tr·∫Øc nghi·ªám', fill_in_the_blank: 'ƒêi·ªÅn t·ª´', word_formation: 'D·∫°ng c·ªßa t·ª´', word_scramble: 'S·∫Øp x·∫øp ch·ªØ c√°i', matching: 'N·ªëi t·ª´', flashcard: 'Flashcards' };
                quizTitle.textContent = typeMap[quizData.quizType];
                let subtitleParts = [];
                if (quizData.quizType === 'vocabulary') { subtitleParts.push(modeMap[quizData.vocabMode]); }
                if (quizData.quizType !== 'grammar') { subtitleParts.push(`Ch·ªß ƒë·ªÅ: ${quizData.topic}`); }
                subtitleParts.push(`Tr√¨nh ƒë·ªô: ${quizData.level.toUpperCase()}`);
                quizSubtitle.textContent = subtitleParts.join(' - ');
            }
            
            scoreEl.style.display = quizData.vocabMode === 'flashcard' ? 'none' : 'block';
            progress.textContent = `C√¢u ${currentQuestionIndex + 1} / ${total}`;
            progressBar.style.width = `${((currentQuestionIndex + 1) / total) * 100}%`;
            
            passageContainer.classList.toggle('hidden', !isReading);
            if (isReading) renderTextWithClickableWords(passageText, quizData.raw.passage);
            audioPlayerContainer.classList.toggle('hidden', !isListening);
            transcriptControls.classList.toggle('hidden', !isListening);
            transcriptContainer.classList.add('hidden'); 
            if (isListening) setupAudioPlayer();
            renderQuestion();
        }

        function renderQuestion() {
            feedbackContainer.innerHTML = '';
            feedbackContainer.className = 'mt-6 p-4 rounded-lg min-h-[100px]';
            nextQuestionButton.classList.add('hidden');
            const questions = quizData.raw.questions || (Array.isArray(quizData.raw) ? quizData.raw : []);
            const currentQuestion = questions[currentQuestionIndex];
            
            optionsContainer.innerHTML = '';
            translateQuestionBtn.style.display = 'inline-block';

            const questionType = currentQuestion.type || 'multiple_choice';

            switch (questionType) {
                case 'flashcard':
                    translateQuestionBtn.style.display = 'none';
                    questionText.textContent = 'Nh·∫•n v√†o th·∫ª ƒë·ªÉ l·∫≠t v√† xem nghƒ©a.';
                    optionsContainer.className = 'flex flex-col items-center gap-4';
                    
                    const cardContainer = document.createElement('div');
                    cardContainer.className = 'flashcard-container w-full';
                    const card = document.createElement('div');
                    card.className = 'flashcard';
                    card.onclick = () => card.classList.toggle('flipped');

                    const front = document.createElement('div');
                    front.className = 'flashcard-face flashcard-front';
                    front.innerHTML = `
                        <div>
                            <div class="flex items-center justify-center">
                                <h3 class="text-4xl font-bold">${currentQuestion.word}</h3>
                                <button class="speak-btn ml-3" onclick="event.stopPropagation(); window.playSpeech('${currentQuestion.word}')">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-sky-600 hover:text-sky-800"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
                                </button>
                            </div>
                            <p class="text-xl text-slate-500 mt-2">${currentQuestion.ipa || ''}</p>
                        </div>
                    `;

                    const back = document.createElement('div');
                    back.className = 'flashcard-face flashcard-back';
                    back.innerHTML = `
                        <h4 class="text-3xl font-semibold">${currentQuestion.meaning}</h4>
                        <p class="mt-4 text-lg italic">"${currentQuestion.example}"</p>
                    `;
                    
                    card.appendChild(front);
                    card.appendChild(back);
                    cardContainer.appendChild(card);
                    optionsContainer.appendChild(cardContainer);
                    
                    handleAnswer(null, true); 
                    break;

                case 'matching':
                    translateQuestionBtn.style.display = 'none';
                    renderTextWithClickableWords(questionText, 'N·ªëi t·ª´ ti·∫øng Anh v·ªõi nghƒ©a t∆∞∆°ng ·ª©ng.');
                    optionsContainer.className = 'grid grid-cols-2 gap-4';

                    const wordsCol = document.createElement('div');
                    wordsCol.className = 'space-y-3';
                    const meaningsCol = document.createElement('div');
                    meaningsCol.className = 'space-y-3';

                    const pairs = currentQuestion.pairs;
                     if (!Array.isArray(pairs)) {
                        showError("L·ªói c√¢u h·ªèi n·ªëi t·ª´: D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá.");
                        return;
                    }
                    const shuffledMeanings = [...pairs].sort(() => Math.random() - 0.5);
                    
                    matchingState.correctPairs = 0;

                    pairs.forEach(pair => {
                        const wordEl = document.createElement('div');
                        wordEl.className = 'matching-item p-3 border-2 rounded-lg text-center';
                        wordEl.textContent = pair.word;
                        wordEl.dataset.word = pair.word;
                        wordEl.onclick = () => handleMatchingSelection(wordEl, 'word');
                        wordsCol.appendChild(wordEl);
                    });

                    shuffledMeanings.forEach(pair => {
                        const meaningEl = document.createElement('div');
                        meaningEl.className = 'matching-item p-3 border-2 rounded-lg text-center';
                        meaningEl.textContent = pair.meaning;
                        meaningEl.dataset.word = pair.word;
                        meaningEl.onclick = () => handleMatchingSelection(meaningEl, 'meaning');
                        meaningsCol.appendChild(meaningEl);
                    });
                    
                    optionsContainer.appendChild(wordsCol);
                    optionsContainer.appendChild(meaningsCol);
                    break;

                case 'word_scramble':
                    translateQuestionBtn.style.display = 'none'; 
                    renderTextWithClickableWords(questionText, currentQuestion.clue);
                    optionsContainer.className = 'flex flex-col items-center gap-4';
                    
                    const scrambleContainer = document.createElement('div');
                    scrambleContainer.className = 'flex justify-center gap-2 my-4 flex-wrap';
                    
                    const scrambleWord = (word) => {
                        if (word.length < 2) return word;
                        let scrambled;
                        do { scrambled = word.split('').sort(() => 0.5 - Math.random()).join(''); } while (scrambled === word);
                        return scrambled;
                    };

                    const scrambled = scrambleWord(currentQuestion.answer);
                    scrambled.split('').forEach(char => {
                        const letterBox = document.createElement('div');
                        letterBox.className = 'w-12 h-12 bg-sky-100 border-2 border-sky-300 rounded-lg flex items-center justify-center text-2xl font-bold text-sky-800 uppercase';
                        letterBox.textContent = char;
                        scrambleContainer.appendChild(letterBox);
                    });
                    optionsContainer.appendChild(scrambleContainer);
                    
                    const textInput = document.createElement('input');
                    textInput.type = 'text';
                    textInput.className = 'w-full md:w-3/4 p-3 border border-slate-400 rounded-lg text-lg text-center focus:ring-2 focus:ring-sky-500 tracking-widest';
                    textInput.placeholder = 'Nh·∫≠p ƒë√°p √°n c·ªßa b·∫°n';
                    textInput.onkeydown = (e) => { if (e.key === 'Enter') checkBtn.click(); };
                    
                    const checkBtn = document.createElement('button');
                    checkBtn.textContent = 'Ki·ªÉm tra';
                    checkBtn.className = 'w-full md:w-3/4 bg-sky-500 hover:bg-sky-600 text-white font-bold py-3 px-4 rounded-lg text-lg';
                    checkBtn.onclick = () => {
                        handleAnswer(textInput.value);
                        textInput.disabled = true;
                        checkBtn.disabled = true;
                        checkBtn.classList.add('opacity-70');
                    };
                    
                    optionsContainer.appendChild(textInput);
                    optionsContainer.appendChild(checkBtn);
                    break;

                case 'multiple_choice':
                default:
                    renderTextWithClickableWords(questionText, currentQuestion.question);
                    optionsContainer.className = 'grid grid-cols-1 md:grid-cols-2 gap-4';
                    const shuffledOptions = [...currentQuestion.options].sort(() => Math.random() - 0.5);
                    shuffledOptions.forEach(option => {
                        const button = document.createElement('button');
                        button.className = "option-btn w-full text-left p-4 border-2 border-slate-300 rounded-lg hover:bg-slate-100 hover:border-sky-400 transition text-lg flex items-center justify-between";
                        const optionText = document.createElement('span');
                        renderTextWithClickableWords(optionText, option); // Make words in options clickable
                        button.appendChild(optionText);
                        button.onclick = () => handleAnswer(option);
                        if (quizData.quizType === 'listening') { button.disabled = true; button.classList.add('opacity-50', 'cursor-not-allowed'); }
                        optionsContainer.appendChild(button);
                    });
                    break;

                case 'fill_in_the_blank':
                case 'word_formation':
                    renderTextWithClickableWords(questionText, currentQuestion.question);
                    optionsContainer.className = 'flex flex-col items-center gap-4';
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'w-full md:w-3/4 p-3 border border-slate-400 rounded-lg text-lg text-center focus:ring-2 focus:ring-sky-500';
                    input.placeholder = 'Nh·∫≠p c√¢u tr·∫£ l·ªùi c·ªßa b·∫°n...';
                    input.onkeydown = (e) => { if (e.key === 'Enter') checkAnswerBtn.click(); };
                    
                    const checkAnswerBtn = document.createElement('button');
                    checkAnswerBtn.textContent = 'Ki·ªÉm tra';
                    checkAnswerBtn.className = 'w-full md:w-3/4 bg-sky-500 hover:bg-sky-600 text-white font-bold py-3 px-4 rounded-lg text-lg';
                    checkAnswerBtn.onclick = () => {
                        handleAnswer(input.value);
                        input.disabled = true;
                        checkAnswerBtn.disabled = true;
                        checkAnswerBtn.classList.add('opacity-70');
                    };
                    optionsContainer.appendChild(input);
                    optionsContainer.appendChild(checkAnswerBtn);
                    break;
            }
        }

        function handleMatchingSelection(selectedEl, type) {
            if (selectedEl.classList.contains('correct')) return;

            if (type === 'word') {
                if (matchingState.selectedWordEl) {
                    matchingState.selectedWordEl.classList.remove('selected');
                }
                matchingState.selectedWordEl = selectedEl;
                selectedEl.classList.add('selected');
            } 
            else if (type === 'meaning' && matchingState.selectedWordEl) {
                const wordData = matchingState.selectedWordEl.dataset.word;
                const meaningData = selectedEl.dataset.word;

                if (wordData === meaningData) {
                    playSound('correct');
                    matchingState.selectedWordEl.className = 'matching-item p-3 border-2 rounded-lg text-center correct';
                    selectedEl.className = 'matching-item p-3 border-2 rounded-lg text-center correct';
                    matchingState.selectedWordEl = null;
                    matchingState.correctPairs++;
                    
                    const totalPairs = quizData.raw[currentQuestionIndex].pairs.length;
                    if (matchingState.correctPairs === totalPairs) {
                        handleAnswer(true);
                    }
                } else {
                    playSound('incorrect');
                    const wordEl = matchingState.selectedWordEl;
                    wordEl.classList.add('incorrect');
                    selectedEl.classList.add('incorrect');
                    matchingState.selectedWordEl = null;

                    setTimeout(() => {
                        wordEl.classList.remove('incorrect', 'selected');
                        selectedEl.classList.remove('incorrect');
                    }, 400);
                }
            }
        }


        function handleAnswer(selectedOption, isFlashcard = false) {
            clearTimeout(autoAdvanceTimer);
            if (isFlashcard) {
                if (autoAdvanceCheckbox.checked) {
                    autoAdvanceTimer = setTimeout(moveToNextQuestion, 3000);
                } else {
                    nextQuestionButton.classList.remove('hidden');
                }
                return;
            }

            const questions = quizData.raw.questions || (Array.isArray(quizData.raw) ? quizData.raw : []);
            const currentQuestion = questions[currentQuestionIndex];
            const questionType = currentQuestion.type || 'multiple_choice';
            
            let isCorrect;

            if (questionType === 'matching') {
                isCorrect = true; 
                score++;
                feedbackContainer.className = 'mt-6 p-4 rounded-lg bg-green-100 text-green-800';
                feedbackContainer.innerHTML = `<b class="font-bold">Ch√≠nh x√°c!</b><p>B·∫°n ƒë√£ n·ªëi ƒë√∫ng t·∫•t c·∫£ c√°c c·∫∑p.</p>`;
            } else if (questionType === 'multiple_choice') {
                isCorrect = selectedOption === currentQuestion.answer;
                Array.from(optionsContainer.children).forEach(button => {
                    button.disabled = true; button.classList.add('opacity-70');
                    if (button.querySelector('span').textContent === currentQuestion.answer) {
                        button.className = "option-btn correct w-full text-left p-4 border-2 border-green-500 bg-green-100 rounded-lg text-lg flex items-center justify-between font-semibold";
                    } else if (button.querySelector('span').textContent === selectedOption) {
                        button.className = "option-btn incorrect w-full text-left p-4 border-2 border-red-500 bg-red-100 rounded-lg text-lg flex items-center justify-between";
                    }
                });
            } else {
                isCorrect = selectedOption.trim().toLowerCase() === currentQuestion.answer.toLowerCase();
            }

            if (questionType !== 'matching') {
                 if (isCorrect) {
                    playSound('correct');
                    score++;
                    feedbackContainer.className = 'mt-6 p-4 rounded-lg bg-green-100 text-green-800';
                    let feedbackHTML = `<b class="font-bold">Ch√≠nh x√°c!</b>`;
                    if(currentQuestion.explanation && (currentQuizType === 'standard' || currentQuizType === 'review')) { feedbackHTML += `<p>${currentQuestion.explanation}</p>`; }
                    feedbackContainer.innerHTML = feedbackHTML;
                } else {
                    playSound('incorrect');
                    feedbackContainer.className = 'mt-6 p-4 rounded-lg bg-red-100 text-red-800';
                    const displayAnswer = `ƒê√°p √°n ƒë√∫ng l√† <b>"${currentQuestion.answer}"</b>.`;
                    let feedbackHTML = `<b class="font-bold">Ch∆∞a ƒë√∫ng.</b> ${displayAnswer}`;
                    if(currentQuestion.explanation && (currentQuizType === 'standard' || currentQuizType === 'review')) { feedbackHTML += `<p>${currentQuestion.explanation}</p>`; }
                    feedbackContainer.innerHTML = feedbackHTML;

                    if (currentQuizType === 'standard' || currentQuizType === 'review') {
                        const reinforceBtn = document.createElement('button');
                        reinforceBtn.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="inline-block mr-2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path><path d="m9 12 2 2 4-4"></path></svg>
                            C·ªßng c·ªë ki·∫øn th·ª©c
                        `;
                        reinforceBtn.className = 'mt-4 w-full bg-fuchsia-500 hover:bg-fuchsia-600 text-white font-bold py-2 px-4 rounded-lg text-md transition';
                        reinforceBtn.onclick = () => requestReinforcement(currentQuestion, selectedOption);
                        feedbackContainer.appendChild(reinforceBtn);
                    }
                }
            }
            
            scoreEl.textContent = `ƒêi·ªÉm: ${score}`;
            
            if (autoAdvanceCheckbox.checked && (currentQuizType === 'standard' || currentQuizType === 'review')) {
                autoAdvanceTimer = setTimeout(moveToNextQuestion, 3000);
            } else {
                nextQuestionButton.classList.remove('hidden');
            }

            sessionResults.push({
                question: currentQuestion,
                userAnswer: selectedOption,
                isCorrect: isCorrect
            });
        }

        async function requestReinforcement(question, userAnswer) {
            showModal(reinforceModal);
            reinforceContent.innerHTML = '<div class="spinner mx-auto"></div>';
            reinforceTitle.textContent = "B√†i h·ªçc t·ª´ AI";

            try {
                const prompt = getReinforcementPrompt(question, userAnswer);
                const result = await model.generateContent(prompt);
                const response = await result.response;
                const lessonData = extractAndParseJson(response.text());

                if (!lessonData) {
                    throw new Error("AI kh√¥ng tr·∫£ v·ªÅ b√†i h·ªçc h·ª£p l·ªá. Vui l√≤ng th·ª≠ l·∫°i.");
                }
                displayReinforcement(lessonData);

            } catch (error) {
                reinforceContent.innerHTML = `<p class="text-center text-red-500">R·∫•t ti·∫øc, kh√¥ng th·ªÉ t·∫°o b√†i h·ªçc ngay l√∫c n√†y. L·ªói: ${error.message}</p>`;
            }
        }

        function displayReinforcement(data) {
            reinforceTitle.textContent = data.conceptTitle;
            reinforceContent.innerHTML = `
                <div class="bg-red-50 p-3 rounded-lg border border-red-200">
                    <h4 class="text-md font-bold text-red-800 mb-1">Ph√¢n t√≠ch l·ªói sai</h4>
                    <div class="text-red-700 prose">${marked.parse(data.mistakeAnalysis)}</div>
                </div>
                <div class="bg-slate-50 p-3 rounded-lg border border-slate-200">
                    <h4 class="text-md font-bold text-slate-800 mb-2">Gi·∫£i th√≠ch kh√°i ni·ªám</h4>
                    <div class="text-slate-700 space-y-2 prose">${marked.parse(data.conceptExplanation)}</div>
                </div>
                <div class="bg-slate-50 p-3 rounded-lg border border-slate-200">
                    <h4 class="text-md font-bold text-slate-800 mb-2">V√≠ d·ª• minh h·ªça</h4>
                    <ul class="space-y-2">
                        ${data.examples.map(ex => `
                            <li class="p-2 rounded-md bg-white">
                                <p class="font-semibold text-sky-700">"${ex.en}"</p>
                                <p class="text-xs text-slate-500 italic">‚Üí ${ex.vi}</p>
                            </li>
                        `).join('')}
                    </ul>
                </div>
                <div class="bg-amber-50 p-3 rounded-lg border border-amber-200">
                    <h4 class="text-md font-bold text-amber-800 mb-1">üí° M·∫πo ghi nh·ªõ</h4>
                    <div class="text-amber-700 prose">${marked.parse(data.practiceTip)}</div>
                </div>
            `;
        }


        function moveToNextQuestion() {
            currentQuestionIndex++;
            const questions = quizData.raw.questions || (Array.isArray(quizData.raw) ? quizData.raw : []);
            const total = questions.length;
            if (currentQuestionIndex < total) {
                renderQuiz();
            } else {
                if (currentQuizType === 'placement' || currentQuizType === 'diagnostic') {
                    showPlacementResult();
                } else if (currentQuizType === 'path') {
                    handlePathStepCompletion(score, total);
                } else {
                    showResult();
                }
            }
        }

        async function showResult() {
            // Reset result view for standard quizzes
            if (currentQuizType === 'review') {
                playAgainButton.textContent = "V·ªÅ b·ªô th·∫ª";
                playAgainButton.onclick = () => { playSound('click'); showDeckDetails(currentDeck.id, currentDeck.name); };
            } else {
                playAgainButton.textContent = "L√†m b√†i kh√°c";
                playAgainButton.onclick = () => { playSound('click'); showView('setup-view'); };
            }
            reviewAnswersButton.textContent = "Xem l·∫°i b√†i l√†m";
            reviewAnswersButton.onclick = () => { playSound('click'); showReviewPage(sessionResults, quizData.raw, 'result-view'); };
            reviewAnswersButton.classList.remove('hidden');
            viewHistoryFromResultButton.classList.remove('hidden');

            const questions = quizData.raw.questions || (Array.isArray(quizData.raw) ? quizData.raw : []);
            const total = questions.length;
            
            resultScoreContainer.style.display = quizData.vocabMode === 'flashcard' ? 'none' : 'block';
            reviewAnswersButton.style.display = quizData.vocabMode === 'flashcard' ? 'none' : 'block';
            
            if (quizData.vocabMode === 'flashcard') {
                resultMessage.textContent = `Tuy·ªát v·ªùi! B·∫°n ƒë√£ √¥n t·∫≠p xong ${total} th·∫ª.`;
            } else {
                if (auth.currentUser && currentQuizType !== 'review') { // Don't save review sessions to history
                    await updateUserStreak(auth.currentUser.uid);
                    try {
                        const resultsCollectionRef = collection(db, "users", auth.currentUser.uid, "quizResults");
                        const newResult = { 
                            level: quizData.level, type: quizData.quizType, score: score, totalQuestions: total, 
                            createdAt: serverTimestamp(), results: sessionResults, 
                            context: { passage: quizData.raw.passage || null, script: quizData.raw.script || null }
                        };
                        if (quizData.quizType !== 'grammar') { newResult.topic = quizData.topic; }
                        if (quizData.quizType === 'vocabulary') { newResult.vocabMode = quizData.vocabMode; }
                        await addDoc(resultsCollectionRef, newResult);
                        userHistoryCache = []; 
                    } catch (e) { console.error("L·ªói khi l∆∞u k·∫øt qu·∫£: ", e); }
                }
                finalScore.textContent = `${score} / ${total}`;
                const percentage = (score / total) * 100;
                if (percentage === 100) resultMessage.textContent = "Tuy·ªát v·ªùi! B·∫°n ƒë√£ tr·∫£ l·ªùi ƒë√∫ng t·∫•t c·∫£!";
                else if (percentage >= 70) resultMessage.textContent = "L√†m t·ªët l·∫Øm! Ki·∫øn th·ª©c c·ªßa b·∫°n r·∫•t ·ªïn.";
                else if (percentage >= 40) resultMessage.textContent = "Kh√° l·∫Øm! Ti·∫øp t·ª•c luy·ªán t·∫≠p nh√©.";
                else resultMessage.textContent = "ƒê·ª´ng n·∫£n l√≤ng! M·ªói l·∫ßn luy·ªán t·∫≠p l√† m·ªôt b∆∞·ªõc ti·∫øn.";
            }
            showView('result-view');
        }
        
        async function showPlacementResult() {
            showView('placement-result-view');
            placementResultContainer.innerHTML = '<div class="spinner mx-auto"></div>';
            diagnosticChartContainer.classList.add('hidden');
            try {
                let analysisData;
                if(currentQuizType === 'diagnostic') {
                    const prompt = getDiagnosticAnalysisPrompt(diagnosticConversationState.history);
                    const result = await model.generateContent(prompt);
                    const response = await result.response;
                    analysisData = extractAndParseJson(response.text());
                    if (!analysisData) throw new Error("AI did not return a valid diagnostic analysis.");
                    
                    renderDiagnosticChart(analysisData.skillsProfile);
                    diagnosticChartContainer.classList.remove('hidden');
                } else {
                    const prompt = getPlacementAnalysisPrompt(sessionResults);
                    const result = await model.generateContent(prompt);
                    const response = await result.response;
                    analysisData = extractAndParseJson(response.text());
                    if (!analysisData) throw new Error("AI did not return a valid placement analysis.");
                }

                placementResultContainer.innerHTML = `
                    <div class="text-center mb-4">
                        <p class="text-lg font-semibold text-indigo-800">Tr√¨nh ƒë·ªô ∆∞·ªõc t√≠nh c·ªßa b·∫°n</p>
                        <p class="text-6xl font-bold text-indigo-600">${analysisData.level || analysisData.overallLevel}</p>
                    </div>
                    <div>
                        <h4 class="text-lg font-bold text-slate-800 mb-2">Ph√¢n t√≠ch t·ª´ AI</h4>
                        <p class="text-slate-700 text-base">${analysisData.analysis}</p>
                    </div>
                `;
                createPathButton.classList.remove('hidden');

                if (auth.currentUser) {
                    const pathRef = doc(db, "learningPaths", auth.currentUser.uid);
                    await setDoc(pathRef, {
                        userId: auth.currentUser.uid,
                        placementTestResult: {
                            level: analysisData.level || analysisData.overallLevel,
                            analysis: analysisData.analysis,
                            score: score,
                            totalQuestions: sessionResults.length,
                            completedAt: serverTimestamp(),
                            type: currentQuizType
                        },
                        status: 'pending_generation'
                    }, { merge: true });
                }

            } catch (error) {
                placementResultContainer.innerHTML = `<p class="text-center text-red-500">R·∫•t ti·∫øc, kh√¥ng th·ªÉ ph√¢n t√≠ch k·∫øt qu·∫£. L·ªói: ${error.message}</p>`;
            }
        }
        
        function renderDiagnosticChart(skillsProfile) {
            if (chartInstance) {
                chartInstance.destroy();
            }
            const ctx = diagnosticChartCanvas.getContext('2d');
            const data = {
                labels: ['Ph√°t √¢m', 'L∆∞u lo√°t', 'Nghe', 'T·ª´ v·ª±ng', 'Ng·ªØ ph√°p'],
                datasets: [{
                    label: 'ƒêi·ªÉm k·ªπ nƒÉng',
                    data: [
                        skillsProfile.pronunciation,
                        skillsProfile.fluency,
                        skillsProfile.listening,
                        skillsProfile.vocabulary,
                        skillsProfile.grammar
                    ],
                    fill: true,
                    backgroundColor: 'rgba(99, 102, 241, 0.2)',
                    borderColor: 'rgb(99, 102, 241)',
                    pointBackgroundColor: 'rgb(99, 102, 241)',
                    pointBorderColor: '#fff',
                    pointHoverBackgroundColor: '#fff',
                    pointHoverBorderColor: 'rgb(99, 102, 241)'
                }]
            };
            const config = {
                type: 'radar',
                data: data,
                options: {
                    elements: { line: { borderWidth: 3 } },
                    scales: { r: { angleLines: { display: false }, suggestedMin: 0, suggestedMax: 100, pointLabels: { font: { size: 14, family: "'Be Vietnam Pro', sans-serif" } } } },
                    plugins: { legend: { display: false } }
                }
            };
            chartInstance = new Chart(ctx, config);
        }

        // --- Learning Path Functions ---
        function showGoalSetting() {
            goalOptionsContainer.innerHTML = '';
            const goals = [
                { key: 'travel', text: 'Giao ti·∫øp khi ƒëi du l·ªãch', icon: '‚úàÔ∏è' },
                { key: 'work', text: 'Ph·ª•c v·ª• c√¥ng vi·ªác', icon: 'üíº' },
                { key: 'certification', text: 'Luy·ªán thi ch·ª©ng ch·ªâ', icon: 'üéì' },
                { key: 'general', text: 'C·∫£i thi·ªán t·ªïng qu√°t', icon: 'üß†' }
            ];

            goals.forEach(goal => {
                const button = document.createElement('button');
                button.className = 'p-6 border-2 border-slate-300 rounded-lg hover:bg-slate-100 hover:border-indigo-400 transition text-lg text-center';
                button.innerHTML = `<div class="text-4xl mb-2">${goal.icon}</div><span class="font-semibold">${goal.text}</span>`;
                button.onclick = () => handleGoalSelection(goal.text);
                goalOptionsContainer.appendChild(button);
            });

            showView('goal-setting-view');
        }

        async function handleGoalSelection(goal) {
            if (!auth.currentUser) return showError("Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ t·∫°o l·ªô tr√¨nh.");

            loadingTitle.textContent = 'AI ƒëang x√¢y d·ª±ng l·ªô tr√¨nh...';
            loadingMessage.textContent = `D·ª±a tr√™n k·∫øt qu·∫£ v√† m·ª•c ti√™u "${goal}" c·ªßa b·∫°n, AI ƒëang t·∫°o ra m·ªôt k·∫ø ho·∫°ch h·ªçc t·∫≠p ƒë·ªôc nh·∫•t.`;
            showView('loading-view');

            try {
                const pathRef = doc(db, "learningPaths", auth.currentUser.uid);
                const docSnap = await getDoc(pathRef);

                if (!docSnap.exists() || !docSnap.data().placementTestResult) {
                    throw new Error("Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ ki·ªÉm tra ƒë·∫ßu v√†o.");
                }
                const placementResult = docSnap.data().placementTestResult;
                
                const prompt = getLearningPathPrompt(placementResult, goal);
                const result = await model.generateContent(prompt);
                const response = await result.response;
                const pathData = extractAndParseJson(response.text());

                if (!pathData || !Array.isArray(pathData)) {
                    throw new Error("AI kh√¥ng tr·∫£ v·ªÅ m·ªôt l·ªô tr√¨nh h·ª£p l·ªá.");
                }

                await setDoc(pathRef, {
                    goal: goal,
                    path: pathData,
                    currentStep: 0,
                    status: 'active',
                    generatedAt: serverTimestamp()
                }, { merge: true });
                
                await checkUserLearningPath(auth.currentUser.uid);
                showLearningPath();

            } catch (error) {
                showError(`Kh√¥ng th·ªÉ t·∫°o l·ªô tr√¨nh. L·ªói: ${error.message}`);
            }
        }

        function showLearningPath() {
            if (!currentUserPath) {
                showError("Kh√¥ng t√¨m th·∫•y l·ªô tr√¨nh h·ªçc t·∫≠p.");
                return;
            }
            renderLearningPath(currentUserPath.path, currentUserPath.currentStep);
            showView('learning-path-view');
        }

        function renderLearningPath(path, currentStep) {
            learningPathContainer.innerHTML = '';
            const icons = {
                grammar: 'üìñ', vocabulary: 'üß†', reading: 'üì∞',
                listening: 'üéß', writing: '‚úçÔ∏è', review: 'üéØ'
            };
            path.forEach((step, index) => {
                const isCompleted = index < currentStep;
                const isActive = index === currentStep;
                const isLocked = index > currentStep;

                const item = document.createElement('div');
                item.className = `p-4 rounded-lg border-2 flex items-center gap-4 transition-all duration-300 ${isCompleted ? 'bg-green-100 border-green-300 opacity-70' : ''} ${isActive ? 'bg-white border-teal-500 shadow-lg scale-105' : ''} ${isLocked ? 'bg-slate-100 border-slate-300 opacity-60' : ''}`;
                
                item.innerHTML = `
                    <div class="text-4xl">${isLocked ? 'üîí' : (icons[step.type] || 'üìö')}</div>
                    <div>
                        <p class="font-bold text-slate-800">${step.description}</p>
                        <p class="text-sm text-slate-500 capitalize">${step.type} - ${step.topic} - Level ${step.level}</p>
                    </div>
                    ${isActive ? `<button class="start-step-btn ml-auto bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-4 rounded-lg">B·∫Øt ƒë·∫ßu</button>` : ''}
                    ${isCompleted ? `<div class="ml-auto text-2xl text-green-500">‚úÖ</div>` : ''}
                `;
                learningPathContainer.appendChild(item);
            });
        }
        
        async function startPathStep() {
            if (!currentUserPath) return showError("Kh√¥ng t√¨m th·∫•y l·ªô tr√¨nh h·ªçc t·∫≠p.");
            
            const step = currentUserPath.path[currentUserPath.currentStep];
            if (!step) return showError("L·ªói: Kh√¥ng t√¨m th·∫•y b∆∞·ªõc h·ªçc hi·ªán t·∫°i.");

            currentQuizType = 'path';
            sessionResults = [];
            score = 0;
            currentQuestionIndex = 0;

            const settings = {
                type: step.type,
                topic: step.topic,
                level: step.level,
                count: (step.type === 'review' || step.type === 'reading' || step.type === 'listening') ? 5 : 10,
                isRetry: true
            };
            
            if (step.type === 'writing') {
                startWritingPractice(settings);
            } else {
                startQuiz(settings);
            }
        }

        async function handlePathStepCompletion(achievedScore, totalScore) {
            if (!auth.currentUser || !currentUserPath) return;

            const step = currentUserPath.path[currentUserPath.currentStep];
            const percentage = totalScore > 0 ? (achievedScore / totalScore) * 100 : 0;
            const passingThreshold = 70; // 70% to pass

            showView('result-view');

            if (percentage >= passingThreshold) {
                // Passed the step
                const newStep = currentUserPath.currentStep + 1;
                const pathRef = doc(db, "learningPaths", auth.currentUser.uid);
                try {
                    await updateDoc(pathRef, { currentStep: newStep });
                    currentUserPath.currentStep = newStep;

                    resultScoreContainer.innerHTML = `<p class="text-2xl font-semibold mb-2 text-teal-700">Ho√†n th√†nh b∆∞·ªõc!</p><p class="text-6xl font-bold text-teal-600">üéâ</p>`;
                    finalScore.textContent = `${achievedScore} / ${totalScore}`;
                    resultMessage.textContent = "L√†m t·ªët l·∫Øm! B·∫°n ƒë√£ m·ªü kh√≥a b∆∞·ªõc ti·∫øp theo trong l·ªô tr√¨nh c·ªßa m√¨nh.";

                    playAgainButton.textContent = "Ti·∫øp t·ª•c L·ªô tr√¨nh";
                    playAgainButton.onclick = showLearningPath;

                    if (step.type === 'writing') {
                        reviewAnswersButton.textContent = "Xem l·∫°i Ph·∫£n h·ªìi";
                        reviewAnswersButton.onclick = () => showView('writing-view');
                    } else {
                        reviewAnswersButton.textContent = "Xem l·∫°i B√†i l√†m";
                        reviewAnswersButton.onclick = () => showReviewPage(sessionResults, quizData.raw, 'result-view');
                    }
                    reviewAnswersButton.classList.remove('hidden');
                    viewHistoryFromResultButton.classList.add('hidden');

                } catch (error) {
                    showError("Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t ti·∫øn ƒë·ªô l·ªô tr√¨nh. L·ªói: " + error.message);
                }
            } else {
                // Failed the step
                resultScoreContainer.innerHTML = `<p class="text-2xl font-semibold mb-2 text-orange-700">Ch∆∞a ƒë·∫°t!</p><p class="text-6xl font-bold text-orange-600">üí™</p>`;
                finalScore.textContent = `${achievedScore} / ${totalScore}`;
                resultMessage.textContent = `B·∫°n c·∫ßn ƒë·∫°t √≠t nh·∫•t ${passingThreshold}% ƒë·ªÉ qua b∆∞·ªõc n√†y. H√£y c·ªë g·∫Øng √¥n t·∫≠p v√† l√†m l·∫°i nh√©!`;

                playAgainButton.textContent = "Th·ª≠ l·∫°i ngay";
                playAgainButton.onclick = startPathStep;

                if (step.type === 'writing') {
                    reviewAnswersButton.textContent = "Xem l·∫°i Ph·∫£n h·ªìi";
                    reviewAnswersButton.onclick = () => showView('writing-view');
                } else {
                    reviewAnswersButton.textContent = "Xem l·∫°i & √în t·∫≠p";
                    reviewAnswersButton.onclick = showReinforcementView;
                }
                reviewAnswersButton.classList.remove('hidden');
                viewHistoryFromResultButton.classList.add('hidden');
            }
        }

        function showReinforcementView() {
            reinforcementReviewList.innerHTML = '';
            const incorrectAnswers = sessionResults.filter(r => !r.isCorrect);

            if (incorrectAnswers.length === 0) {
                reinforcementReviewList.innerHTML = '<p class="text-center text-slate-500">Tuy·ªát v·ªùi, b·∫°n kh√¥ng l√†m sai c√¢u n√†o trong l·∫ßn th·ª≠ n√†y!</p>';
            } else {
                incorrectAnswers.forEach((result, index) => {
                    const item = document.createElement('div');
                    const q = result.question;
                    item.className = 'p-4 rounded-lg bg-red-50 border border-red-200';
                    item.innerHTML = `
                        <p class="font-semibold text-slate-800">${index + 1}. ${q.question || q.clue}</p>
                        <p class="text-sm text-slate-700 mt-2">C√¢u tr·∫£ l·ªùi c·ªßa b·∫°n: <b class="text-red-700 font-semibold">${result.userAnswer || '(Ch∆∞a tr·∫£ l·ªùi)'}</b></p>
                        <p class="text-sm text-slate-700 mt-1">ƒê√°p √°n ƒë√∫ng: <b class="text-green-700 font-semibold">${q.answer}</b></p>
                        <button class="reinforce-btn mt-3 bg-fuchsia-500 hover:bg-fuchsia-600 text-white text-xs font-bold py-1 px-3 rounded-full" data-question-index="${sessionResults.indexOf(result)}">
                            B√†i h·ªçc t·ª´ AI
                        </button>
                    `;
                    reinforcementReviewList.appendChild(item);
                });
            }
            showView('reinforcement-view');
        }

        // --- Review & History Functions ---
        function showReviewPage(results, context, cameFromView) {
            reviewList.innerHTML = '';
            reviewCameFrom = cameFromView; 
            showView('review-view');

            if (context?.passage) {
                const passageEl = document.createElement('div');
                passageEl.className = 'p-4 mb-6 bg-slate-100 rounded-lg border border-slate-200';
                passageEl.innerHTML = `<h3 class="text-lg font-bold mb-2 text-slate-700">ƒêo·∫°n vƒÉn</h3><p>${context.passage}</p>`;
                reviewList.appendChild(passageEl);
            }
            if (context?.script) {
                const scriptEl = document.createElement('div');
                scriptEl.className = 'p-4 mb-6 bg-slate-100 rounded-lg border border-slate-200';
                scriptEl.innerHTML = `<h3 class="text-lg font-bold mb-2 text-slate-700">L·ªùi tho·∫°i</h3><p class="italic">"${context.script}"</p>`;
                reviewList.appendChild(scriptEl);
            }

            results.forEach((result, index) => {
                const item = document.createElement('div');
                const q = result.question;
                const userAnswer = result.userAnswer;
                const isCorrect = result.isCorrect;

                item.className = `p-4 rounded-lg border-2 mb-4 ${isCorrect ? 'border-green-300 bg-green-50' : 'border-red-300 bg-red-50'}`;
                
                if (q.type === 'matching') {
                     item.innerHTML = `<p class="font-semibold text-slate-800">${index + 1}. N·ªëi t·ª´</p><div class="mt-2 text-sm text-slate-600">B·∫°n ƒë√£ ho√†n th√†nh c√¢u h·ªèi n√†y.</div><ul class="mt-3 pt-3 border-t border-slate-300 space-y-1">${q.pairs.map(p => `<li class="text-sm"><b>${p.word}</b>: ${p.meaning}</li>`).join('')}</ul>`;
                } else {
                    const resultIcon = isCorrect ? '<span class="text-green-600 font-bold">‚úÖ ƒê√∫ng</span>' : '<span class="text-red-600 font-bold">‚ùå Sai</span>';
                    let answerDetail = '';
                    if (!isCorrect) { answerDetail = `<p class="text-sm text-slate-700 mt-2">ƒê√°p √°n ƒë√∫ng: <b class="text-green-700 font-semibold">${q.answer}</b></p>`; }
                    const questionContent = q.question || `G·ª£i √Ω: ${q.clue}`;
                    const explanationHTML = q.explanation ? `<p class="mt-3 pt-3 border-t border-slate-300 text-sm text-slate-600"><b class="font-semibold">Gi·∫£i th√≠ch:</b> ${q.explanation}</p>` : '';

                    item.innerHTML = `<p class="font-semibold text-slate-800">${index + 1}. ${questionContent}</p><p class="text-sm text-slate-700 mt-2">C√¢u tr·∫£ l·ªùi c·ªßa b·∫°n: <b class="${isCorrect ? 'text-green-700' : 'text-red-700'} font-semibold">${userAnswer || '(Ch∆∞a tr·∫£ l·ªùi)'}</b> ${resultIcon}</p>${answerDetail}${explanationHTML}`;
                }
                reviewList.appendChild(item);
            });
        }
        
        async function reviewHistoricQuiz(resultId) {
            if (!auth.currentUser) return;
            historyList.innerHTML = '<div class="spinner mx-auto"></div>'; 
            try {
                const resultDocRef = doc(db, "users", auth.currentUser.uid, "quizResults", resultId);
                const docSnap = await getDoc(resultDocRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    if (data.type === 'writing') {
                        quizData = { topic: data.topic, level: data.level, quizType: 'writing' };
                        showView('writing-view');
                        writingTopic.textContent = data.topic;
                        writingInput.value = data.originalText;
                        writingInput.disabled = true;
                        getFeedbackButton.disabled = true;
                        displayWritingFeedback(data.feedback);
                        writingFeedbackContainer.classList.remove('hidden');
                    } else {
                        showReviewPage(data.results, data.context, 'history-view');
                    }
                } else {
                    showError("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu b√†i l√†m n√†y.");
                }
            } catch (error) {
                console.error("L·ªói khi t·∫£i b√†i l√†m ƒë·ªÉ xem l·∫°i:", error);
                showError("Kh√¥ng th·ªÉ t·∫£i b√†i l√†m ƒë·ªÉ xem l·∫°i.");
            }
        }

        async function showHistory() {
            if (!auth.currentUser) { showError("B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ xem l·ªãch s·ª≠."); return; }
            showView('history-view');
            historyList.innerHTML = '<div class="spinner mx-auto"></div>';
            historyDashboard.innerHTML = '';
            recommendationsContainer.innerHTML = '';
            try {
                const historyCollectionRef = collection(db, "users", auth.currentUser.uid, "quizResults");
                const q = query(historyCollectionRef);
                const querySnapshot = await getDocs(q);
                userHistoryCache = querySnapshot.docs.map(doc => ({id: doc.id, ...doc.data()}));
                
                if (userHistoryCache.length === 0) { 
                    historyList.innerHTML = '<p class="text-center text-slate-500">B·∫°n ch∆∞a c√≥ l·ªãch s·ª≠ l√†m b√†i n√†o.</p>'; 
                    historyDashboard.innerHTML = '';
                    recommendationsContainer.innerHTML = '';
                    return; 
                }
                const stats = calculateStats(userHistoryCache);
                displayHistoryStats(stats);
                generateRecommendations(stats);
                renderHistoryList();
            } catch (error) {
                console.error("L·ªói khi t·∫£i l·ªãch s·ª≠: ", error);
                historyList.innerHTML = '<p class="text-center text-red-500">Kh√¥ng th·ªÉ t·∫£i l·ªãch s·ª≠.</p>';
            }
        }
        
        function renderHistoryList() {
            const skill = filterSkill.value;
            const level = filterLevel.value;
            const filteredResults = userHistoryCache.filter(res => (skill === 'all' || res.type === skill) && (level === 'all' || res.level === level));
            if (filteredResults.length === 0) { historyList.innerHTML = '<p class="text-center text-slate-500">Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ ph√π h·ª£p.</p>'; return; }
            historyList.innerHTML = '';
            filteredResults.sort((a,b) => (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0)).forEach(data => {
                const date = data.createdAt ? new Date(data.createdAt.seconds * 1000).toLocaleString('vi-VN') : 'N/A';
                const typeMap = { vocabulary: 'T·ª´ v·ª±ng', reading: 'ƒê·ªçc hi·ªÉu', grammar: 'Ng·ªØ ph√°p', listening: 'Nghe hi·ªÉu', writing: 'Luy·ªán vi·∫øt' };
                const typeText = typeMap[data.type] || 'Kh√¥ng x√°c ƒë·ªãnh';
                
                const topicText = (data.type !== 'grammar') ? `<p class="font-bold text-base text-slate-800 capitalize">${data.topic} <span class="text-sm font-normal text-indigo-600">(${typeText})</span></p>` : `<p class="font-bold text-base text-slate-800 capitalize">${typeText}</p>`;
                
                let scoreText;
                if (data.type === 'writing') {
                    scoreText = `<p class="font-bold text-xl text-cyan-600">${data.feedback.score}/100</p>`;
                } else {
                    scoreText = `<p class="font-bold text-xl ${data.score / data.totalQuestions >= 0.7 ? 'text-green-600' : 'text-orange-500'}">${data.score}/${data.totalQuestions}</p>`;
                }

                const item = document.createElement('div');
                item.className = 'bg-slate-50 p-3 rounded-lg border border-slate-200';
                item.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div>
                            ${topicText}
                            <div class="text-xs text-slate-500 mt-1">
                                <span>Tr√¨nh ƒë·ªô: ${data.level.toUpperCase()}</span> | <span>${date}</span>
                            </div>
                        </div>
                        ${scoreText}
                    </div>
                    <div class="flex justify-end items-center space-x-2 mt-2 pt-2 border-t border-slate-200">
                        <button class="review-hist-button bg-purple-500 hover:bg-purple-600 text-white text-xs font-bold py-1 px-3 rounded-full" data-result-id="${data.id}">Xem l·∫°i</button>
                        <button class="retry-button bg-sky-500 hover:bg-sky-600 text-white text-xs font-bold py-1 px-3 rounded-full" data-type="${data.type}" data-topic="${data.topic || ''}" data-level="${data.level}">L√†m l·∫°i</button>
                    </div>`;
                historyList.appendChild(item);
            });
            
            document.querySelectorAll('.retry-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    playSound('click');
                    const { type, topic, level } = e.target.dataset;
                    if (type === 'writing') {
                        startWritingPractice();
                    } else {
                        startQuiz({ type, topic, level });
                    }
                });
            });
            document.querySelectorAll('.review-hist-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    playSound('click');
                    reviewHistoricQuiz(e.target.dataset.resultId);
                });
            });
        }

        function calculateStats(results) {
            let totalCorrect = 0, totalQuestions = 0;
            const skillStats = { vocabulary: {c:0, t:0}, reading: {c:0, t:0}, grammar: {c:0, t:0}, listening: {c:0, t:0}, writing: {c:0, t:0} };
            const topicStats = {};
            results.forEach(res => {
                if (res.type === 'writing') {
                    skillStats.writing.c += res.feedback.score;
                    skillStats.writing.t += 100;
                } else {
                    totalCorrect += res.score; totalQuestions += res.totalQuestions;
                    if (skillStats[res.type]) { skillStats[res.type].c += res.score; skillStats[res.type].t += res.totalQuestions; }
                }
                if (res.type !== 'grammar') { if (!topicStats[res.topic]) topicStats[res.topic] = {c:0, t:0}; topicStats[res.topic].c += (res.type === 'writing' ? res.feedback.score : res.score); topicStats[res.topic].t += (res.type === 'writing' ? 100 : res.totalQuestions); }
            });
            return { totalCorrect, totalQuestions, skillStats, topicStats };
        }

        function displayHistoryStats(stats) {
            const { skillStats } = stats;
            const overallQuizCorrect = stats.totalCorrect;
            const overallQuizTotal = stats.totalQuestions;
            const overallWritingScore = skillStats.writing.c;
            const overallWritingAttempts = skillStats.writing.t / 100;

            let overallRate = 0;
            if (overallQuizTotal + skillStats.writing.t > 0) {
                overallRate = Math.round(((overallQuizCorrect + overallWritingScore) / (overallQuizTotal + skillStats.writing.t)) * 100);
            }
            
            const findBest = (s) => Object.entries(s).filter(([, v]) => v.t > 0).reduce((b, [k, v]) => (v.c / v.t > b.rate ? { key: k, rate: v.c / v.t } : b), { key: 'N/A', rate: -1 });
            const bestSkill = findBest(skillStats);
            const bestTopic = findBest(stats.topicStats);
            const typeMap = { vocabulary: 'T·ª´ v·ª±ng', reading: 'ƒê·ªçc hi·ªÉu', grammar: 'Ng·ªØ ph√°p', listening: 'Nghe hi·ªÉu', writing: 'Luy·ªán vi·∫øt' };
            historyDashboard.innerHTML = `
                <div class="bg-blue-100 p-4 rounded-lg"><div class="text-sm text-blue-600 font-semibold">T·ª∑ l·ªá ƒë√∫ng</div><div class="text-3xl font-bold text-blue-800">${overallRate}%</div></div>
                <div class="bg-green-100 p-4 rounded-lg"><div class="text-sm text-green-600 font-semibold">K·ªπ nƒÉng t·ªët nh·∫•t</div><div class="text-2xl font-bold text-green-800 capitalize">${typeMap[bestSkill.key] || 'Ch∆∞a c√≥'}</div></div>
                <div class="bg-purple-100 p-4 rounded-lg"><div class="text-sm text-purple-600 font-semibold">Ch·ªß ƒë·ªÅ t·ªët nh·∫•t</div><div class="text-2xl font-bold text-purple-800 capitalize">${bestTopic.key || 'Ch∆∞a c√≥'}</div></div>`;
        }

        async function generateRecommendations(stats) {
            const { skillStats } = stats;
            const recommendations = [];
            const findWorst = (s) => Object.entries(s).filter(([, v]) => v.t > 0).reduce((w, [k, v]) => (v.c / v.t < w.rate ? { key: k, rate: v.c / v.t } : w), { key: 'N/A', rate: 2 });
            const worstSkill = findWorst(skillStats);
            const typeMap = { vocabulary: 'T·ª´ v·ª±ng', reading: 'ƒê·ªçc hi·ªÉu', grammar: 'Ng·ªØ ph√°p', listening: 'Nghe hi·ªÉu', writing: 'Luy·ªán vi·∫øt' };
            if (worstSkill.key !== 'N/A' && worstSkill.rate < 0.7) {
                recommendations.push({ text: `C√≥ v·∫ª b·∫°n c·∫ßn c·∫£i thi·ªán k·ªπ nƒÉng <b>${typeMap[worstSkill.key]}</b>. Th·ª≠ m·ªôt b√†i ngay?`, settings: { type: worstSkill.key, level: 'B1', topic: 'General' } });
            }
            const findBest = (s) => Object.entries(s).filter(([, v]) => v.t > 2).reduce((b, [k, v]) => (v.c / v.t > b.rate ? { key: k, rate: v.c / v.t } : b), { key: 'N/A', rate: -1 });
            const bestSkill = findBest(skillStats);
            const levelOrder = ['A2', 'B1', 'B2', 'C1'];
            if (bestSkill.key !== 'N/A' && bestSkill.rate > 0.8) {
                const currentLevelIndex = levelOrder.indexOf('B1');
                if (currentLevelIndex < levelOrder.length - 1) {
                    const nextLevel = levelOrder[currentLevelIndex + 1];
                    recommendations.push({ text: `B·∫°n l√†m r·∫•t t·ªët <b>${typeMap[bestSkill.key]}</b>! Th·ª≠ s·ª©c ·ªü tr√¨nh ƒë·ªô <b>${nextLevel}</b> nh√©?`, settings: { type: bestSkill.key, level: nextLevel, topic: 'General' } });
                }
            }
            if (recommendations.length === 0 && userHistoryCache.length > 0) {
                recommendations.push({ text: "B·∫°n ƒëang l√†m r·∫•t t·ªët! H√£y ti·∫øp t·ª•c ph√°t huy nh√©!", settings: null });
            }
            recommendationsContainer.innerHTML = recommendations.length > 0 ? `<h3 class="text-lg font-bold text-slate-700 mb-2">G·ª£i √Ω cho b·∫°n</h3>` : '';
            recommendations.forEach(rec => {
                const recButton = document.createElement('button');
                recButton.innerHTML = rec.text;
                recButton.className = "w-full text-left p-3 bg-yellow-100 border border-yellow-300 text-yellow-800 rounded-lg hover:bg-yellow-200 transition mb-2";
                if (rec.settings) { recButton.onclick = () => startPractice(rec.settings); } 
                else { recButton.disabled = true; }
                recommendationsContainer.appendChild(recButton);
            });
        }
        
        // --- Audio Functions ---
        function playSpeech(text, startIndex = 0) {
            if (synth.speaking) { synth.cancel(); }
            isPausedByUser = false;
            const utterance = new SpeechSynthesisUtterance(text.substring(startIndex));
            const voices = synth.getVoices();
            let selectedVoice = voices.find(voice => voice.name === 'Google US English' || voice.name === 'Microsoft David - English (United States)');
            if (!selectedVoice) {
                selectedVoice = voices.find(voice => voice.lang.startsWith('en-')) || voices[0];
            }
            utterance.voice = selectedVoice;
            utterance.rate = 0.9;
            utterance.pitch = 1;

            if (transcriptContainer.offsetParent !== null) { 
                const words = text.split(/(\s+)/);
                const wordElements = words.map(word => { const span = document.createElement('span'); span.textContent = word; return span; });
                transcriptContainer.innerHTML = '';
                wordElements.forEach(el => transcriptContainer.appendChild(el));
                let charCounter = 0;
                const wordBoundaries = words.map(word => { const start = charCounter; charCounter += word.length; return { word, start, end: charCounter }; });
                utterance.onboundary = (event) => {
                    lastSpokenCharIndex = startIndex + event.charIndex;
                    wordElements.forEach(el => el.classList.remove('highlight-word'));
                    for(let i = 0; i < wordBoundaries.length; i++) {
                        if (lastSpokenCharIndex >= wordBoundaries[i].start && lastSpokenCharIndex < wordBoundaries[i].end) {
                            wordElements[i].classList.add('highlight-word');
                            break;
                        }
                    }
                };
            }
            
            utterance.onstart = () => { audioState = 'playing'; playIcon.classList.add('hidden'); pauseIcon.classList.remove('hidden'); audioStatus.textContent = "ƒêang ph√°t..."; };
            utterance.onend = () => {
                if (!isPausedByUser) {
                    lastSpokenCharIndex = 0; audioState = 'idle';
                    playIcon.classList.remove('hidden'); pauseIcon.classList.add('hidden');
                    audioStatus.textContent = "Nghe l·∫°i";
                    if(optionsContainer.offsetParent !== null) {
                        Array.from(optionsContainer.children).forEach(button => { button.disabled = false; button.classList.remove('opacity-50', 'cursor-not-allowed'); });
                    }
                    if (transcriptContainer.offsetParent !== null) {
                       transcriptContainer.querySelectorAll('span').forEach(el => el.classList.remove('highlight-word'));
                    }
                }
            };
            utterance.onerror = (e) => { audioState = 'idle'; audioStatus.textContent = "L·ªói ph√°t √¢m thanh"; console.error("SpeechSynthesis Error:", e); };
            synth.speak(utterance);
        }
        window.playSpeech = playSpeech;

        function setupAudioPlayer() {
            audioState = 'idle'; lastSpokenCharIndex = 0;
            playIcon.classList.remove('hidden'); pauseIcon.classList.add('hidden');
            audioStatus.textContent = "Nh·∫•n ƒë·ªÉ nghe"; playAudioBtn.disabled = false;
        }

        // --- Library & History Saving ---
        async function saveWritingResult(originalText, feedback) {
            if (!auth.currentUser) return;
            const resultsCollectionRef = collection(db, "users", auth.currentUser.uid, "quizResults");
            const newResult = {
                level: quizData.level,
                type: 'writing',
                topic: writingTopic.textContent,
                originalText: originalText,
                feedback: feedback,
                createdAt: serverTimestamp()
            };
            try {
                await addDoc(resultsCollectionRef, newResult);
                userHistoryCache = []; // Invalidate cache
            } catch (error) {
                console.error("L·ªói khi l∆∞u k·∫øt qu·∫£ luy·ªán vi·∫øt: ", error);
            }
        }

        async function saveQuizToLibrary(quizDataToSave) {
            if (!auth.currentUser) return;
            const libraryRef = collection(db, "quizLibrary");
            const extractVocabulary = (questions) => {
                const vocabulary = [];
                if (!Array.isArray(questions)) return vocabulary;
                questions.forEach(q => {
                    if (q.type === 'matching' && Array.isArray(q.pairs)) { q.pairs.forEach(pair => vocabulary.push({ word: pair.word, meaning: pair.meaning, ipa: '' })); } 
                    else if (q.type === 'flashcard' && q.word) { vocabulary.push({ word: q.word, meaning: q.meaning, ipa: q.ipa || '' }); } 
                    else if (q.answer) { vocabulary.push({ word: q.answer, meaning: q.explanation || q.clue || 'Xem gi·∫£i th√≠ch trong b√†i.', ipa: q.ipa || '' }); }
                });
                return vocabulary;
            };
            try {
                const quizContent = quizDataToSave.raw;
                const relatedVocabulary = extractVocabulary(Array.isArray(quizContent) ? quizContent : (quizContent?.questions || []));
                const dataToSave = {
                    creatorId: auth.currentUser.uid, level: quizDataToSave.level, quizType: quizDataToSave.quizType,
                    count: quizDataToSave.count, quizContent: quizContent || {}, createdAt: serverTimestamp(), relatedVocabulary: relatedVocabulary
                };
                if (quizDataToSave.quizType !== 'grammar') { dataToSave.topic = quizDataToSave.topic; }
                if (quizDataToSave.quizType === 'vocabulary') { dataToSave.vocabMode = quizDataToSave.vocabMode; }
                await addDoc(libraryRef, dataToSave);
            } catch (error) { console.error("Error saving quiz to library:", error); }
        }

        async function showLibrary() {
            if (!auth.currentUser) { showError("B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ xem th∆∞ vi·ªán."); return; }
            showView('library-view');
            libraryList.innerHTML = '<div class="spinner mx-auto"></div>';
            const libraryRef = collection(db, "quizLibrary");
            try {
                const querySnapshot = await getDocs(query(libraryRef));
                const quizzes = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderLibraryList(quizzes);
            } catch (error) { console.error("Error fetching quiz library:", error); libraryList.innerHTML = '<p class="text-center text-red-500">Kh√¥ng th·ªÉ t·∫£i th∆∞ vi·ªán.</p>'; }
        }

        function renderLibraryList(quizzes) {
            if (quizzes.length === 0) { libraryList.innerHTML = '<p class="text-center text-slate-500">Th∆∞ vi·ªán c·ªßa b·∫°n c√≤n tr·ªëng.</p>'; return; }
            libraryList.innerHTML = '';
            quizzes.sort((a,b) => (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0)).forEach(quiz => {
                const date = quiz.createdAt ? new Date(quiz.createdAt.seconds * 1000).toLocaleDateString('vi-VN') : 'N/A';
                const typeText = quiz.quizType === 'reading' ? 'ƒê·ªçc hi·ªÉu' : (quiz.quizType === 'grammar' ? 'Ng·ªØ ph√°p' : (quiz.quizType === 'listening' ? 'Nghe hi·ªÉu' : 'T·ª´ v·ª±ng'));
                const item = document.createElement('div');
                item.className = 'bg-slate-50 p-3 rounded-lg border border-slate-200';
                item.innerHTML = `<p class="font-bold text-base text-slate-800 capitalize">${quiz.topic || 'Ng·ªØ ph√°p t·ªïng h·ª£p'} <span class="text-sm font-normal text-amber-600">(${typeText})</span></p><div class="text-xs text-slate-500 mt-1"><span>Tr√¨nh ƒë·ªô: ${quiz.level.toUpperCase()}</span> | <span>${quiz.count || (quiz.quizContent?.questions?.length || quiz.quizContent?.length)} c√¢u</span> | <span>Ng√†y t·∫°o: ${date}</span></div><div class="flex justify-end items-center space-x-2 mt-2 pt-2 border-t border-slate-200"><button class="retry-library-btn bg-sky-500 hover:bg-sky-600 text-white text-xs font-bold py-1 px-3 rounded-full" data-quiz-id="${quiz.id}">L√†m l·∫°i</button></div>`;
                libraryList.appendChild(item);
            });
            document.querySelectorAll('.retry-library-btn').forEach(button => { button.addEventListener('click', (e) => retrySavedQuiz(e.target.dataset.quizId)); });
        }

        async function retrySavedQuiz(quizId) {
            const docRef = doc(db, "quizLibrary", quizId);
            try {
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) {
                    const savedQuiz = docSnap.data();
                    currentQuizType = 'standard';
                    quizData = {
                        topic: savedQuiz.topic, level: savedQuiz.level, quizType: savedQuiz.quizType,
                        vocabMode: savedQuiz.vocabMode, count: savedQuiz.count, raw: savedQuiz.quizContent, isRetry: true
                    };
                    sessionResults = []; currentQuestionIndex = 0; score = 0;
                    renderQuiz(); showView('quiz-view');
                }
            } catch (error) { showError("Kh√¥ng th·ªÉ t·∫£i l·∫°i b√†i t·∫≠p n√†y."); }
        }
        
        // --- Diagnostic Conversation Functions ---
        function initSpeechRecognition() {
            window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!window.SpeechRecognition) {
                alert("R·∫•t ti·∫øc, tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ nh·∫≠n d·∫°ng gi·ªçng n√≥i. Vui l√≤ng s·ª≠ d·ª•ng Chrome ho·∫∑c Edge.");
                micButton.disabled = true;
                return;
            }
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.lang = 'en-US';
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                handleUserResponse(transcript, 'speech');
            };

            recognition.onspeechend = () => { recognition.stop(); };
            recognition.onend = () => { micButton.classList.remove('mic-recording', 'bg-red-400'); micButton.disabled = false; };
            recognition.onerror = (event) => { console.error("Speech recognition error", event.error); micButton.classList.remove('mic-recording', 'bg-red-400'); micButton.disabled = false; };
        }

        function addMessageToLog(sender, text, type = 'text') {
            const messageDiv = document.createElement('div');
            let contentHTML = `<p class="p-3 rounded-lg ${sender === 'ai' ? 'bg-slate-200 text-slate-800' : 'bg-indigo-100 text-indigo-800'}">${text}</p>`;
            messageDiv.innerHTML = `<div class="font-bold text-sm mb-1 ${sender === 'ai' ? 'text-slate-600' : 'text-indigo-600'}">${sender === 'ai' ? 'AI' : 'B·∫°n'}</div>${contentHTML}`;
            conversationLog.appendChild(messageDiv);
            conversationLog.scrollTop = conversationLog.scrollHeight;
            if (sender === 'user') { diagnosticConversationState.history.push({ role: 'user', text: text, inputType: type }); } 
            else { diagnosticConversationState.history.push({ role: 'ai', text: text }); }
        }

        async function handleUserResponse(text, type = 'text') {
            if (!text.trim()) return;
            addMessageToLog('user', text, type);
            conversationTextInput.value = '';
            conversationInputArea.classList.add('hidden');
            const thinkingDiv = document.createElement('div');
            thinkingDiv.innerHTML = `<div class="font-bold text-sm mb-1 text-slate-600">AI</div><div class="p-3 rounded-lg bg-slate-200 text-slate-800"><div class="spinner h-5 w-5 border-2 border-left-color-slate-400"></div></div>`;
            conversationLog.appendChild(thinkingDiv);
            conversationLog.scrollTop = conversationLog.scrollHeight;
            try {
                const history = diagnosticConversationState.history.map(h => `${h.role}: ${h.text}`).join('\n');
                const prompt = `This is a diagnostic conversation. The user just said: "${text}". The history is:\n${history}\n\nAsk a follow-up question to gauge their English level. If the conversation has had more than 6 turns, say "Thank you! I have enough information now. I will now analyze your results."`;
                const result = await fastModel.generateContent(prompt);
                const response = await result.response;
                const aiResponse = response.text();
                conversationLog.removeChild(thinkingDiv);
                addMessageToLog('ai', aiResponse);
                playSpeech(aiResponse);
                if (aiResponse.includes("analyze your results")) {
                    endDiagnosticConversationButton.textContent = "Xem k·∫øt qu·∫£";
                    endDiagnosticConversationButton.onclick = showPlacementResult;
                } else {
                    conversationInputArea.classList.remove('hidden');
                }
            } catch (error) {
                console.error("Error in diagnostic conversation:", error);
                conversationLog.removeChild(thinkingDiv);
                addMessageToLog('ai', "I'm sorry, I encountered an error. Let's end the conversation here.");
                endDiagnosticConversationButton.textContent = "K·∫øt th√∫c";
                endDiagnosticConversationButton.onclick = () => showView('setup-view');
            }
        }

        async function startDiagnosticConversation() {
            currentQuizType = 'diagnostic';
            sessionResults = [];
            score = 0;
            diagnosticConversationState = { history: [], startTime: new Date() };
            showView('diagnostic-conversation-view');
            conversationLog.innerHTML = '';
            conversationInputArea.classList.remove('hidden');
            endDiagnosticConversationButton.textContent = "K·∫øt th√∫c";
            endDiagnosticConversationButton.onclick = () => {
                if(recognition) recognition.stop();
                if(synth.speaking) synth.cancel();
                showView('setup-view');
            };
            const initialPrompt = "Let's start with a simple question. What did you do last weekend?";
            addMessageToLog('ai', initialPrompt);
            playSpeech(initialPrompt);
        }

        // --- Event Listeners & Setup ---
        function handleQuizTypeChange() {
            const selectedType = quizTypeSelect.value;
            const isVocab = selectedType === 'vocabulary';
            const isWriting = selectedType === 'writing';
            const isTopicBased = isVocab || selectedType === 'reading' || selectedType === 'listening' || isWriting;
            vocabModeContainer.style.maxHeight = isVocab ? '150px' : '0'; 
            vocabModeContainer.style.opacity = isVocab ? '1' : '0';
            vocabModeContainer.style.marginTop = isVocab ? '1.5rem' : '0';
            questionCountContainer.style.display = isWriting ? 'none' : 'block';
            if (!isTopicBased) {
                topicContainer.style.maxHeight = '0'; 
                topicContainer.style.opacity = '0';
                topicContainer.style.marginTop = '0';
                customTopicContainer.classList.add('hidden');
            } else {
                topicContainer.style.maxHeight = '150px'; 
                topicContainer.style.opacity = '1';
                topicContainer.style.marginTop = '1.5rem';
                if (topicSelect.value === 'custom') {
                    customTopicContainer.classList.remove('hidden');
                } else {
                    customTopicContainer.classList.add('hidden');
                }
            }
        }

        const addSoundToListener = (element, event, callback) => {
            if (!element) return;
            element.addEventListener(event, (e) => {
                playSound('click');
                callback(e);
            });
        };

        addSoundToListener(loginButton, 'click', () => handleAuthAction('login'));
        addSoundToListener(registerButton, 'click', () => handleAuthAction('register'));
        addSoundToListener(logoutButton, 'click', handleLogout);
        addSoundToListener(startQuizButton, 'click', startPractice);
        addSoundToListener(quickStartButton, 'click', quickStartPractice);
        addSoundToListener(backToSetupButton, 'click', () => showView('setup-view'));
        addSoundToListener(showHistoryButton, 'click', showHistory);
        addSoundToListener(showNotebookButton, 'click', showNotebookDecks);
        addSoundToListener(showLibraryButton, 'click', showLibrary);
        addSoundToListener(backToSetupFromLibrary, 'click', () => showView('setup-view'));
        addSoundToListener(backToSetupFromHistory, 'click', () => showView('setup-view'));
        addSoundToListener(viewHistoryFromResultButton, 'click', showHistory);
        addSoundToListener(nextQuestionButton, 'click', moveToNextQuestion);
        addSoundToListener(translateQuestionBtn, 'click', () => showTranslationModal(getTranslation(questionText.textContent)));
        addSoundToListener(closeTranslationModal, 'click', () => hideModal(translationModal));
        addSoundToListener(closeReinforceModal, 'click', () => hideModal(reinforceModal));
        addSoundToListener(closeWordInfoModal, 'click', () => hideModal(wordInfoModal));
        addSoundToListener(backToPreviousViewButton, 'click', () => showView(reviewCameFrom));
        addSoundToListener(backToSetupFromWriting, 'click', () => { currentQuizType === 'path' ? showLearningPath() : showView('setup-view'); });
        addSoundToListener(getFeedbackButton, 'click', getWritingFeedback);
        addSoundToListener(startPlacementTestButton, 'click', () => showView('assessment-choice-view'));
        addSoundToListener(backToSetupFromChoice, 'click', () => showView('setup-view'));
        addSoundToListener(startTraditionalTestButton, 'click', startPlacementTest);
        addSoundToListener(startDiagnosticConversationButton, 'click', startDiagnosticConversation);
        addSoundToListener(backToSetupFromPlacement, 'click', () => showView('setup-view'));
        addSoundToListener(createPathButton, 'click', showGoalSetting);
        addSoundToListener(continuePathButton, 'click', showLearningPath);
        addSoundToListener(backToSetupFromPath, 'click', () => showView('setup-view'));
        addSoundToListener(backToPathFromReinforcement, 'click', showLearningPath);
        addSoundToListener(retryPathStepFromReinforcement, 'click', startPathStep);
        
        // Notebook v4 Listeners
        addSoundToListener(backToSetupFromDecks, 'click', () => showView('setup-view'));
        addSoundToListener(backToDecksListButton, 'click', showNotebookDecks);
        addSoundToListener(showCreateDeckModalButton, 'click', () => showModal(createDeckModal));
        addSoundToListener(cancelCreateDeckBtn, 'click', () => hideModal(createDeckModal));
        addSoundToListener(confirmCreateDeckBtn, 'click', handleCreateDeck);
        addSoundToListener(quickLookupButton, 'click', handleQuickLookupAndSave);
        addSoundToListener(reviewSelectedWordsButton, 'click', startReviewFromDeck);
        addSoundToListener(deleteSelectedWordsButton, 'click', handleDeleteSelectedWords);
        
        deckListContainer.addEventListener('click', (e) => {
            const card = e.target.closest('.deck-card');
            const deleteBtn = e.target.closest('.delete-deck-btn');
            if (deleteBtn) {
                e.stopPropagation();
                playSound('click');
                handleDeleteDeck(deleteBtn.dataset.deckId);
            } else if (card) {
                playSound('click');
                showDeckDetails(card.dataset.deckId, card.dataset.deckName);
            }
        });
        
        deckWordList.addEventListener('change', (e) => {
            if (e.target.classList.contains('word-checkbox')) {
                updateReviewButtonState();
            }
        });
        
        selectAllWordsCheckbox.addEventListener('change', (e) => {
            deckWordList.querySelectorAll('.word-checkbox').forEach(cb => {
                cb.checked = e.target.checked;
            });
            updateReviewButtonState();
        });

        deckSearchInput.addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            const filteredWords = currentDeck.words.filter(word => 
                word.word.toLowerCase().includes(searchTerm) || 
                word.definition.toLowerCase().includes(searchTerm)
            );
            renderDeckWordList(filteredWords);
        });

        quickLookupInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                handleQuickLookupAndSave();
            }
        });

        quizTypeSelect.addEventListener('change', handleQuizTypeChange);
        topicSelect.addEventListener('change', () => {
            customTopicContainer.classList.toggle('hidden', topicSelect.value !== 'custom');
        });
        filterSkill.addEventListener('change', renderHistoryList);
        filterLevel.addEventListener('change', renderHistoryList);
        
        playAudioBtn.addEventListener('click', () => {
            if (audioState === 'playing') {
                isPausedByUser = true; synth.cancel(); audioState = 'paused';
                playIcon.classList.remove('hidden'); pauseIcon.classList.add('hidden');
                audioStatus.textContent = "ƒê√£ t·∫°m d·ª´ng";
            } else { playSpeech(quizData.raw.script, lastSpokenCharIndex); }
        });
        
        showTranscriptBtn.addEventListener('click', () => {
            const isHidden = transcriptContainer.classList.toggle('hidden');
            showTranscriptBtn.textContent = isHidden ? 'Hi·ªán l·ªùi tho·∫°i' : '·∫®n l·ªùi tho·∫°i';
        });

        reviewAnswersButton.addEventListener('click', () => {
            playSound('click');
            const context = { passage: quizData.raw.passage || null, script: quizData.raw.script || null };
            showReviewPage(sessionResults, context, 'result-view');
        });
        
        writingInput.addEventListener('input', () => {
            const text = writingInput.value;
            const count = text.trim() === '' ? 0 : text.trim().split(/\s+/).length;
            wordCount.textContent = `${count} t·ª´`;
        });

        document.getElementById('quiz-view').addEventListener('click', (e) => {
            if (e.target.classList.contains('lookup-word')) {
                showWordInfo(e.target.textContent);
            }
        });

        appContainer.addEventListener('click', (e) => {
            if (e.target && e.target.closest('.start-step-btn')) {
                playSound('click');
                startPathStep();
            }
            if (e.target && e.target.closest('.reinforce-btn')) {
                playSound('click');
                const resultIndex = parseInt(e.target.closest('.reinforce-btn').dataset.questionIndex, 10);
                const result = sessionResults[resultIndex];
                requestReinforcement(result.question, result.userAnswer);
            }
        });

        micButton.addEventListener('click', () => {
            playSound('click');
            if (!recognition) {
                initSpeechRecognition();
                if(!recognition) return;
            }
            micButton.classList.add('mic-recording', 'bg-red-400');
            micButton.disabled = true;
            recognition.start();
        });

        sendTextButton.addEventListener('click', () => {
            playSound('click');
            handleUserResponse(conversationTextInput.value);
        });
        conversationTextInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                playSound('click');
                handleUserResponse(conversationTextInput.value);
            }
        });

        // Initial setup
        handleQuizTypeChange();

    </script>
</body>
</html>
